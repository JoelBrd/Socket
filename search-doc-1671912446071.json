[{"title":"Janitor","type":0,"sectionRef":"#","url":"api/Janitor","content":"On this page Janitor See Janitor","keywords":""},{"title":"Logger","type":0,"sectionRef":"#","url":"api/Logger","content":"","keywords":""},{"title":"Functions‚Äã","type":1,"pageTitle":"Logger","url":"api/Logger#functions","content":" "},{"title":"MacroInfo‚Äã","type":1,"pageTitle":"Logger","url":"api/Logger#MacroInfo","content":"&lt;/&gt; Logger:MacroInfo( macro:¬†MacroDefinition, ...:¬†any ) ‚Üí¬†() For showing general information to the output  "},{"title":"MacroWarn‚Äã","type":1,"pageTitle":"Logger","url":"api/Logger#MacroWarn","content":"&lt;/&gt; Logger:MacroWarn( macro:¬†MacroDefinition, ...:¬†any ) ‚Üí¬†() For informing the user that an issue with a macro has occured "},{"title":"Promise","type":0,"sectionRef":"#","url":"api/Promise","content":"On this page Promise See Promise","keywords":""},{"title":"InstanceUtil","type":0,"sectionRef":"#","url":"api/InstanceUtil","content":"","keywords":""},{"title":"Functions‚Äã","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#functions","content":" "},{"title":"IntroduceInstance‚Äã","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#IntroduceInstance","content":"&lt;/&gt; InstanceUtil:IntroduceInstance( instance:¬†Instance , dontSetWaypoint:¬†boolean¬†|¬†nil ) ‚Üí¬†() Brings an instance into the workspace in the context of Socket and the user calling this function. By default, sets a ChangeHistoryService waypoint.  "},{"title":"ClearInstance‚Äã","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#ClearInstance","content":"&lt;/&gt; InstanceUtil:ClearInstance( instance:¬†Instance , doDestroy:¬†boolean ) ‚Üí¬†() Clears an instance from our context of Socket and the user calling this function. Should be an instance that was introduced via IntroduceInstance "},{"title":"MacroFieldType","type":0,"sectionRef":"#","url":"api/MacroFieldType","content":"","keywords":""},{"title":"Properties‚Äã","type":1,"pageTitle":"MacroFieldType","url":"api/MacroFieldType#properties","content":" "},{"title":"Name‚Äã","type":1,"pageTitle":"MacroFieldType","url":"api/MacroFieldType#Name","content":"&lt;/&gt; MacroFieldType.Name: string The string that should be referenced inside a MacroDefinition for a MacroField's MacroFieldType Socket comes with the following types: &quot;string&quot;|&quot;number&quot;|&quot;boolean&quot;|&quot;Color3&quot;|&quot;Vector3&quot; There is currently no support for adding new types (unless you fork the repo and develop your own)  "},{"title":"Icon‚Äã","type":1,"pageTitle":"MacroFieldType","url":"api/MacroFieldType#Icon","content":"&lt;/&gt; MacroFieldType.Icon: string A small string/emoji "},{"title":"Functions‚Äã","type":1,"pageTitle":"MacroFieldType","url":"api/MacroFieldType#functions","content":" "},{"title":"Validate‚Äã","type":1,"pageTitle":"MacroFieldType","url":"api/MacroFieldType#Validate","content":"&lt;/&gt; MacroFieldType.Validate(value:¬†string) ‚Üí¬†any¬†|¬†nil Takes an input value, and returns a type-safe version. Can return nil if there is nothing we can do with it.  "},{"title":"ToString‚Äã","type":1,"pageTitle":"MacroFieldType","url":"api/MacroFieldType#ToString","content":"&lt;/&gt; MacroFieldType.ToString(value:¬†any) ‚Üí¬†string Takes a type-safe value, and returns it as a string that can be put into the field TextBox on the UI. "},{"title":"Advanced Concepts","type":0,"sectionRef":"#","url":"docs/AdvancedConcepts","content":"","keywords":""},{"title":"Run on Startup‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#run-on-startup","content":"You may want some routines that are always running in the background to bolster your workflow (e.g., ensuring no parts are Anchored=false under a specific directory) You can declare AutoRun=true in your MacroDefinition to allow this. note This functionality can be enabled/disabld in the Settings caution This may cause unintended behaviour in Team Create, as the same code may be being ran on multiple clients "},{"title":"Group Aesthetics‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#group-aesthetics","content":"For organisation purposes, you may not like having a random MacroDefinition defining the aesthetics of the Group it is under. Check out Disabled for more information "},{"title":"Undo/Redo‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#undoredo","content":"You have to option to add EnableAutomaticUndo, so if running your Macro makes any changes they can be undone. Your Macro may need something more advanced than this though (see the &quot;Dot to Dot&quot; macro, where you can undo/redo the placement of nodes) where while it's running will make multiple changes. In these kind of cases, you'll want to use ChangeHistoryService directly. "},{"title":"Messy Macros‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#messy-macros","content":"&quot;Messy Macro&quot; meaning a Macro that makes multiple changes/additions while it's running (e.g., add new Instances to game.Workspace). Good examples of these are &quot;.Locked&quot; and &quot;Dot to Dot&quot;. "},{"title":"RunJanitor‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#runjanitor","content":"Janitor is a very useful class; it's implementation into Socket allows us to pass Instances/Functions/Connections that will be cleaned up when a Macro stops running. See RunJanitor for more details, along with ToggleIsRunning andBindToClose "},{"title":"Edge cases for cleaning up‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#edge-cases-for-cleaning-up","content":"BindToClose‚Äã When we have a toggleable Macro, that can be turned on/off (indicated on the Widget by a green &quot;Running&quot; button), it's could be messy while it is running. We could clean stuff up when we click the Run button again (calls Function), but what if we close Socket or delete the ModuleScript linked to that Macro? In these cases, BindToClose should always be utilised for cleaning stuff up for edge cases. BindToOpen‚Äã Unfortunately, there is a limitation where we cannot detect when Roblox Studio closes (and some cases when a Plugin is closed). Imagine we have a Macro running that turns some parts pink, and studio crashes. If we are on Team Create, when we rejoin those parts will be pink.. but the code that would've reverted this change is not running, and has no knowledge that it should clean up these pink parts! BindToOpen saves the day; whenever a Macro is first initiated (Plugin start, ModuleScript added) we run BindToOpen. Here you can put safety routines to ensure any mess from a bad session end is cleaned up. For an example implementation, check out the source of the &quot;.Locked&quot; Macro which utilisesCollectionService to tag Instances that it has made changes to. "},{"title":"TeamCreate‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#teamcreate","content":"Socket was designed to try accomodate for Team Create, with multiple team members using Socket at the same time. InstanceUtil has some very useful methods for accomodating for this. Take a look at &quot;Dot to Dot&quot; and the heirachy of Instances it creates in game.Workspace. "},{"title":"SoftRequire‚Äã","type":1,"pageTitle":"Advanced Concepts","url":"docs/AdvancedConcepts#softrequire","content":"Whilst developing macros, you may find the use for a Util file - maybe you have multiple macros that use the same logic. It makes sense to compartmentalise this logic into a single Util file, and using require() in your macros. The issue with using require() is that all calls will uses the cached value from the first require(). If a first version of our Util is this: -- Util local Util = { a = 1 } return Util -- Macro local Util = require(Util) print(Util) -- Output: { a = 1 }  Any future require() calls will still give the old cached value: -- Util local Util = { a = 1 b = 2 } return Util -- Macro local Util = require(Util) print(Util) -- Output: { a = 1 }  Using SoftRequire allows us to always have the most up to date version of the Util file. "},{"title":"SocketSettings","type":0,"sectionRef":"#","url":"api/SocketSettings","content":"","keywords":""},{"title":"Properties‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#properties","content":" "},{"title":"Font‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#Font","content":"&lt;/&gt; SocketSettings.Font: Enum.Font The Font used on the widget. Defaults to Enum.Font.Highway  "},{"title":"UIScale‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#UIScale","content":"&lt;/&gt; SocketSettings.UIScale: number This can be tweaked to change the scaling of the UI. Useful for users on a high DPI monitor, or a user that benefits from larger text. Defaults to 1  "},{"title":"OpenFieldsByDefault‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#OpenFieldsByDefault","content":"&lt;/&gt; SocketSettings.OpenFieldsByDefault: boolean The widget uses toggle arrows to show/hide information. If true, the &quot;Fields&quot; sections inside macros will be open by default. Just saves the user another click. Defaults to true  "},{"title":"SortType‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#SortType","content":"&lt;/&gt; SocketSettings.SortType: string Can take a variety of string values to define how Macros and Groups are sorted on the widget. &quot;LayoutOrder&quot; Uses Layout Order to define sorting. The group with the Macro with the lowest LayoutOrder will be at the top of the widget. &quot;Icon&quot; Will sort Macros and Groups by their Icon using &lt;. This results in Macros and Groups with matching Icons being grouped next to one another. &quot;Name&quot; Sorts Macros and Groups alphabetically by name. This behaviour also underlies the other sort types when there isn't a distinct difference (e.g., same Icon, same LayoutOrder) Defaults to &quot;Name&quot;  "},{"title":"OSType‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#OSType","content":"&lt;/&gt; SocketSettings.OSType: string Can take a variety of string values to define the OS you are on. This is useful to translate the Ctrl/Cmd keybinds across OS types. &quot;Windows&quot; Converts Enum.KeyCode.LeftMeta and Enum.KeyCode.RightMeta to Enum.KeyCode.LeftControl and Enum.KeyCode.RightControl &quot;Mac&quot; Converts Enum.KeyCode.LeftControl and Enum.KeyCode.RightControl to Enum.KeyCode.LeftMeta and Enum.KeyCode.RightMeta Defaults to &quot;Windows&quot;  "},{"title":"IgnoreGameProcessedKeybinds‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#IgnoreGameProcessedKeybinds","content":"&lt;/&gt; SocketSettings.IgnoreGameProcessedKeybinds: boolean If true, will not discard UserInputService#InputBegan events where gameProcessed=true. Defaults to false  "},{"title":"EnableSocketMacros‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#EnableSocketMacros","content":"&lt;/&gt; SocketSettings.EnableSocketMacros: boolean Declares if Socket should automatically add its pre-packaged Macros. If false, and you delete all the default Macros, they will not reappear when you restart Socket. Defaults to true  "},{"title":"EnableSocketMacrosOverwrite‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#EnableSocketMacrosOverwrite","content":"&lt;/&gt; SocketSettings.EnableSocketMacrosOverwrite: boolean Slightly softer version of EnableSocketMacros. By default, Socket will delete+add its pre-packaged Macros on startup. This means that any user-made changes to the ModuleScripts will be overwritten. Set this to false to disable this behaviour. Defaults to true  "},{"title":"EnableAutoRun‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#EnableAutoRun","content":"&lt;/&gt; SocketSettings.EnableAutoRun: boolean If false, will ignore the .AutoRun member in any MacroDefinition Defaults to true  "},{"title":"LocalMacroColor‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#LocalMacroColor","content":"v1.1.0 &lt;/&gt; SocketSettings.LocalMacroColor: Color3  This is the color used to make Local Macros stand out from other macros on the widget. Defaults to Color3.fromRGB(0, 231, 193)  "},{"title":"UseDefaultSettings‚Äã","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#UseDefaultSettings","content":"&lt;/&gt; SocketSettings.UseDefaultSettings: boolean If true, will reset ALL settings back to their default value (including UseDefaultSettings=false) "},{"title":"SoftRequire","type":0,"sectionRef":"#","url":"api/SoftRequire","content":"","keywords":""},{"title":"Functions‚Äã","type":1,"pageTitle":"SoftRequire","url":"api/SoftRequire#functions","content":" "},{"title":"Require‚Äã","type":1,"pageTitle":"SoftRequire","url":"api/SoftRequire#Require","content":"&lt;/&gt; SoftRequire:Require(moduleScript:¬†ModuleScript ) ‚Üí¬†table Passed a ModuleScript, will require a Clone() of it. This has the benefit of softRequire(moduleScript) ~= softRequire(moduleScript), whereas require(moduleScript) == require(moduleScript). This gets round the cached value that require() uses. This is beneficial, as during development you may be constantly updating your Util files. After a macro uses require() on a Util, any further require() calls will use a cached value from the first call. This gets round this issue, and allows us for our macros to always have access to the most up to date version of our Util files. "},{"title":"Changelog","type":0,"sectionRef":"#","url":"docs/Changelog","content":"","keywords":""},{"title":"v1.2.0‚Äã","type":1,"pageTitle":"Changelog","url":"docs/Changelog#v120","content":"Fix issues with docking from the recent Studio overhaulFixed bug with Local Macros where ModuleScripts with duplicate names would silently not get savedRemoved &quot;Clone&quot; built-in macro, as this behaviour mirrors Ctrl+DAdd in luau type definitionsUpdate &quot;Create Macro&quot; macro to use luau type definitions for better UX "},{"title":"v1.2.1‚Äã","type":1,"pageTitle":"Changelog","url":"docs/Changelog#v121","content":"Fix typo with luau type MacroField.Validator "},{"title":"v1.1.0‚Äã","type":1,"pageTitle":"Changelog","url":"docs/Changelog#v110","content":"Added Local Macros (see IsLocalMacro), which allows replication of macros across multiple places via the plugin itself.Added LocalMacroColor settingImproved logic behind the settings system to be more scalable + easier to add new settings of different types "},{"title":"v1.0.0‚Äã","type":1,"pageTitle":"Changelog","url":"docs/Changelog#v100","content":"Release! "},{"title":"RaycastUtil","type":0,"sectionRef":"#","url":"api/RaycastUtil","content":"","keywords":""},{"title":"Functions‚Äã","type":1,"pageTitle":"RaycastUtil","url":"api/RaycastUtil#functions","content":" "},{"title":"RaycastMouse‚Äã","type":1,"pageTitle":"RaycastUtil","url":"api/RaycastUtil#RaycastMouse","content":"&lt;/&gt; RaycastUtil:RaycastMouse( distance:¬†number, raycastParams:¬†RaycastParams¬†|¬†nil, checkAllCollisionGroups:¬†boolean¬†|¬†nil ) ‚Üí¬†() Sends a raycast from our camera to the point our mouse is at in the world. checkAllCollisionGroups=true will make sure we raycast against parts that don't collide with the &quot;Default&quot; Collision Group (see the &quot;.Locked&quot; macro)  "},{"title":"Raycast‚Äã","type":1,"pageTitle":"RaycastUtil","url":"api/RaycastUtil#Raycast","content":"&lt;/&gt; RaycastUtil:Raycast( origin:¬†Vector3 , direction:¬†Vector3 , distance:¬†number, raycastParams:¬†RaycastParams¬†|¬†nil, checkAllCollisionGroups:¬†boolean¬†|¬†nil ) ‚Üí¬†() Does a bog standard raycast. checkAllCollisionGroups=true will make sure we raycast against parts that don't collide with the &quot;Default&quot; Collision Group (see the &quot;.Locked&quot; macro) "},{"title":"Contributing","type":0,"sectionRef":"#","url":"docs/Contributing","content":"","keywords":""},{"title":"Todo List‚Äã","type":1,"pageTitle":"Contributing","url":"docs/Contributing#todo-list","content":""},{"title":"Planned‚Äã","type":1,"pageTitle":"Contributing","url":"docs/Contributing#planned","content":"This a list of features that we want implemented into Socket: Prompt undeclared fields in a popup screen (as a separate UI element, outside of the Widget)Global IsRunning, so if a teammate starts running a Macro on their client this will also be indicated on your client (and you can stop running it)IsDangerous option, that will require a confirmation click before running FunctionMake Roact/Rodux logic cleaner (Socket was my first time using Roact and Rodux!) "},{"title":"Ideas‚Äã","type":1,"pageTitle":"Contributing","url":"docs/Contributing#ideas","content":"This is a list of features that are being considered to be implemented: Saving/Loading of Macros across multiple Studio placesRefresh button on the Widget to reload the Plugin "},{"title":"MacroDefinition","type":0,"sectionRef":"#","url":"api/MacroDefinition","content":"","keywords":""},{"title":"Types‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#types","content":" "},{"title":"MacroState‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#MacroState","content":"&lt;/&gt; interface MacroState { FieldValues:¬†table&lt;MacroField.Name,any&gt;-- Where we can read the values in our fields from IsRunning:¬†boolean¬†|¬†nil-- Use this variable to toggle the state of a Macro (updates the UI) IsKeybindDisabled:¬†boolean¬†|¬†nil-- An internal variable for declaring whether a keybind has been disabled or not _Server:¬†MacroState-- Socket-only (used for communcicating Server/Client in Accurate Play Solo) _Client:¬†MacroState-- Socket-only (used for communcicating Server/Client in Accurate Play Solo) } A table to store a macro's &quot;State&quot;. Socket writes some stuff here, but feel free to use this for whatever you need. If you overwrite any keys that Socket uses (fields defined here), expect mayhem and tears! "},{"title":"Properties‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#properties","content":" "},{"title":"Name‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Name","content":"Required &lt;/&gt; MacroDefinition.Name: string Declares the name that will appear on the Widget for the Macro. caution Longer names will be less readable on the Widget, depending on a user's resolution  "},{"title":"NameColor‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#NameColor","content":"Populated &lt;/&gt; MacroDefinition.NameColor: Color3  Give your Macro a pretty color on the Widget! Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Icon‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Icon","content":"Populated &lt;/&gt; MacroDefinition.Icon: string Defines an icon to put alongside the Name of the Macro. This can either be Text (e.g., Emoji) or an ImageId. ImageIds are recognised by the string containing rbxasset { Icon = &quot;üìÇ&quot; -- Good Icon = &quot;My Icon&quot; -- Probably too long, but good Icon = &quot;&quot; -- Bit boring, but good Icon = &quot;rbxassetid://9553550332&quot; -- Good ImageId Icon = &quot;https://www.roblox.com/library/9553550338/&quot; -- Bad ImageId (Website) Icon = &quot;http://www.roblox.com/asset/?id=9553550332&quot; -- Bad ImageId (Decal) } Defaults to &quot;‚ùì&quot;  "},{"title":"IconColor‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#IconColor","content":"Populated &lt;/&gt; MacroDefinition.IconColor: Color3  Give your Macro icon a pretty color on the Widget! Applies to TextColor3 or ImageColor3, depending on Icon input Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Group‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Group","content":"Populated &lt;/&gt; MacroDefinition.Group: string The group that the Macro belongs to. Any macros with a matching Group value will be grouped together on the Widget Defaults to &quot;No Group&quot;  "},{"title":"GroupColor‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#GroupColor","content":"Populated &lt;/&gt; MacroDefinition.GroupColor: Color3  Give the Group text a pretty color on the Widget! If you have multiple Macros under the same Group, GroupColor need only be defined on a singular MacroDefinition. Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"GroupIcon‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#GroupIcon","content":"Populated &lt;/&gt; MacroDefinition.GroupIcon: string Defines an icon to put alongside the name of the Group the Macro is under. If you have multiple Macros under the same Group, GroupIcon need only be defined on a singular MacroDefinition This can either be Text (e.g., Emoji) or an ImageId. ImageIds are recognised by the string containing rbxasset { Icon = &quot;üìÇ&quot; -- Good Icon = &quot;My Icon&quot; -- Probably too long, but good Icon = &quot;&quot; -- Bit boring, but good Icon = &quot;rbxassetid://9553550332&quot; -- Good ImageId Icon = &quot;https://www.roblox.com/library/9553550338/&quot; -- Bad ImageId (Website) Icon = &quot;http://www.roblox.com/asset/?id=9553550332&quot; -- Bad ImageId (Decal) } Defaults to &quot;‚ùì&quot;  "},{"title":"GroupIconColor‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#GroupIconColor","content":"Populated &lt;/&gt; MacroDefinition.GroupIconColor: Color3  Give your Macro icon a pretty color on the Widget! Applies to TextColor3 or ImageColor3, depending on Icon input. If you have multiple Macros under the same Group, GroupIconColor need only be defined on a singular MacroDefinition Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Description‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Description","content":"Populated &lt;/&gt; MacroDefinition.Description: string Any and all information pertaining to this specific Macro. This can be as long as you like as it appears in the output. { Description = &quot;Macro Description Line 1\\nMacro Description Line 2&quot; } Output: ================ Macro Name (Macro Group) | DESCRIPTION ================ Macro Description Line 1 Macro Description Line 2 ================ Macro Name (Macro Group) | DESCRIPTION ================ Defaults to &quot;No Description&quot;  "},{"title":"LayoutOrder‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#LayoutOrder","content":"Populated &lt;/&gt; MacroDefinition.LayoutOrder: number Can be used to define the position of where the Macro is rendered on the Widget. Higher numbers are rendered further down the widget. Works very much the same as LayoutOrder on Roblox Instances. See Settings Defaults to 0  "},{"title":"EnableAutomaticUndo‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#EnableAutomaticUndo","content":"Populated &lt;/&gt; MacroDefinition.EnableAutomaticUndo: boolean If true, will automatically setup ChangeHistoryService waypoints before and after running the Macro's Function. AKA, any changes to studio that your Macro makes, you can undo with Ctrl+Z or equivalent. You can obviously set this to false (or don't declare the field) if you want to write your own implementation. tip When you run &quot;Undo&quot; in Studio, it will undo the last change under the DataModel (game). If, for example, your Macro just prints to the output (and doesn't make any changes to the DataModel) it will undo the last change unrelated to your Macro Defaults to false  "},{"title":"IgnoreGameProcessedKeybinds‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#IgnoreGameProcessedKeybinds","content":"Populated &lt;/&gt; MacroDefinition.IgnoreGameProcessedKeybinds: boolean Socket uses UserInputService#InputBegan for detecting keybinds. game:GetService(&quot;UserInputService&quot;).InputBegan:Connect(function(inputObject, gameProcessedEvent) if gameProcessedEvent and not IgnoreGameProcessedKeybinds then return end ... end) Defaults to false  "},{"title":"AutoRun‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#AutoRun","content":"Populated &lt;/&gt; MacroDefinition.AutoRun: boolean If true, macro.Function will be called when Socket starts. Useful if there is a macro you want to run on startup. Defaults to false  "},{"title":"IsLocalMacro‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#IsLocalMacro","content":"Populated v1.1.0 &lt;/&gt; MacroDefinition.IsLocalMacro: boolean If a macro is a &quot;Local Macro&quot;, this value will be populated as true. Local Macros replicate across different roblox places by being stored under the Socket plugin. You can add a Local Macro by placing it under game.ServerStorage.SocketPlugin.LocalMacros[userId] -- Where userId is your own userId tip Don't know what your userId is? It's the number in the URL of your profile, or you can find it by running the following in the command line: print(game:GetService(&quot;StudioService&quot;):GetUserId())   "},{"title":"Keybind‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Keybind","content":"Populated &lt;/&gt; MacroDefinition.Keybind: {Enum.KeyCode} An array of Enum.KeyCode that can trigger the Macro to run. { Keybind = { Enum.KeyCode.LeftControl, Enum.KeyCode.J } } tip Will not work if any of the inputs have gameProcessedEvent set to true. See: UserInputService To disable this, see [TODO] Defaults to {}  "},{"title":"Fields‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Fields","content":"Populated &lt;/&gt; MacroDefinition.Fields: {MacroField} An array of MacroField, which define the different fields the Macro has. The order they are defined is the order they will appear on the widget. { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; }, { Name = &quot;Title&quot;; Type = &quot;string&quot;; } } } Defaults to {}  "},{"title":"FieldChanged‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#FieldChanged","content":"Read-Only &lt;/&gt; MacroDefinition.FieldChanged: BindableEvent  A BindableEvent to listen to field values being changed on the UI! macro.FieldChanged.Event:Connect(function(fieldName, fieldValue) print(macro:GetFieldValue(fieldName) == fieldValue) end) -- Output: true Most cases it will suffice to just read macro:GetFieldValue(fieldName) as and when you need a field value. But sometimes you may want to re-run routines after a field value change.  "},{"title":"State‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#State","content":"Populated &lt;/&gt; MacroDefinition.State: MacroState A persistent State of the Macro while the Socket plugin is running. We can write to this inside the MacroDefinition, and read/write to it in our Function and BindToClose/BindToOpen functions. We can declare default values for fields: { Fields = { { Name = &quot;Size&quot;; Type = &quot;Vector3&quot;; } } State = { FieldValues = { Size = Vector3.new(2, 2, 2); -- Will automatically appear on the Widget } } } We can also access IsRunning: local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- MacroDefinition that, when running, will print the time since the last frame { Function = function(macro, plugin) -- Toggle running state macro:ToggleIsRunning() -- Running routine if macro:IsRunning() then -- Add to our RunJanitor -- Automatically gets cleaned up when we toggle IsRunning to false via ToggleIsRunning -- Also gets cleaned up when BindToClose is called macro.RunJanitor:Add(Heartbeat:Connect(function(dt) Logger:MacroInfo(macro, (&quot;dt: %f&quot;)) end)) end end } Defaults to { FieldValues = {}; IsRunning = false; _Server = {}; _Client = {}; }   "},{"title":"RunJanitor‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#RunJanitor","content":"Read-Only &lt;/&gt; MacroDefinition.RunJanitor: Janitor A Janitor object, intended to be used to cleanup tasks after a macro stops running. Is automatically cleaned up when using macro:ToggleIsRunning(), and on BindToClose  "},{"title":"Disabled‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Disabled","content":"Populated &lt;/&gt; MacroDefinition.Disabled: boolean If true, this Macro will not be displayed on the Widget. It's Function will also not be required, nor registered. This renders AutoRun useless for this specific MacroDefinition tip This can be useful to create a MacroDefinition solely for defining the aesthetics of a Group for organisation purposes. { Group = &quot;Fruity Macros&quot;, GroupIcon = &quot;üçé&quot;, GroupColor = Color3.fromRGB(200, 20, 20), Disabled = true, } Defaults to false "},{"title":"Functions‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#functions","content":" "},{"title":"Function‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#Function","content":"Required &lt;/&gt; MacroDefinition.Function( macro:¬†MacroDefinition, plugin:¬†Plugin ) ‚Üí¬†() The function that will be called when we Run the Macro. caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent  "},{"title":"BindToClose‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#BindToClose","content":"&lt;/&gt; MacroDefinition.BindToClose( macro:¬†MacroDefinition, plugin:¬†Plugin ) ‚Üí¬†() This is a function that is called when: The Socket Plugin is exited The Macro is removed while the Socket Plugin is running Use this to clean anything up instantiated by the Macro caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent Order of operations: 1) BindToClose is called 2) macro.State.IsRunning = false 3) macro.RunJanitor:Cleanup()  "},{"title":"BindToOpen‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#BindToOpen","content":"&lt;/&gt; MacroDefinition.BindToOpen( macro:¬†MacroDefinition, plugin:¬†Plugin ) ‚Üí¬†() This is a function that is called when the Socket plugin is started! This has some rare use cases. For the most part, Socket is really good at calling BindToClose when it is needed, but there are some Roblox limitations. Imagine we have a macro that makes significant changes in game.Workspace (e.g., changes the Color3 of part(s)). If Roblox Studio is suddenly closed, or crashes, it's possible the changes the macro made will be saved, but the &quot;stopping&quot; logic is never run. BindToOpen can be used to run checks to cleanup any mess left from the previous session. This is more a failsafe than a requirement, but can save headaches! For a good example use-case, see the Socket Core Macro .Locked caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent  "},{"title":"GetFieldValue‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#GetFieldValue","content":"Read-Only &lt;/&gt; MacroDefinition:GetFieldValue(fieldName:¬†string) ‚Üí¬†any Sugar for macro.State.FieldValues[fieldName]   "},{"title":"ToggleIsRunning‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#ToggleIsRunning","content":"Read-Only &lt;/&gt; MacroDefinition:ToggleIsRunning() ‚Üí¬†() Sugar for macro.State.IsRunning = not macro.State.IsRunning if not macro.State.IsRunning then macro.RunJanitor:Cleanup() end   "},{"title":"IsRunning‚Äã","type":1,"pageTitle":"MacroDefinition","url":"api/MacroDefinition#IsRunning","content":"Read-Only &lt;/&gt; MacroDefinition:IsRunning() ‚Üí¬†boolean Returns true if the Macro is running (macro.State.IsRunning == true). False otherwise. Sugar for macro.State.IsRunning  "},{"title":"MacroField","type":0,"sectionRef":"#","url":"api/MacroField","content":"","keywords":""},{"title":"Properties‚Äã","type":1,"pageTitle":"MacroField","url":"api/MacroField#properties","content":" "},{"title":"Type‚Äã","type":1,"pageTitle":"MacroField","url":"api/MacroField#Type","content":"Required &lt;/&gt; MacroField.Type: MacroFieldType The type of data this field will take (e.g., &quot;number&quot;). See MacroFieldType#Name for the options available!  "},{"title":"Name‚Äã","type":1,"pageTitle":"MacroField","url":"api/MacroField#Name","content":"Required &lt;/&gt; MacroField.Name: string The name of this field. This is the same string used to reference this field within a macro.  "},{"title":"IsRequired‚Äã","type":1,"pageTitle":"MacroField","url":"api/MacroField#IsRequired","content":"&lt;/&gt; MacroField.IsRequired: boolean If true, the macro will not run + produce a MacroWarn in the output if a value has not been defined. "},{"title":"Functions‚Äã","type":1,"pageTitle":"MacroField","url":"api/MacroField#functions","content":" "},{"title":"Validator‚Äã","type":1,"pageTitle":"MacroField","url":"api/MacroField#Validator","content":"&lt;/&gt; MacroField.Validator(value:¬†any) ‚Üí¬†string We can define a Validator function to run our field value by when we run the macro. If there is an issue, we have Validator return a string detailing the issue. If everything is OK, return nil. An example use case is if we have a &quot;number&quot; field, but we want to make sure it is non-negative. { Name = &quot;Height&quot;; MacroFieldType = &quot;number&quot;; Validator = function(someNumber) if someNumber &lt; 0 then return (&quot;Must be non-negative. Got: %d&quot;):format(someNumber) end end }  "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method 1 - Plugin‚Äã","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1---plugin","content":"Download the plugin here via Roblox "},{"title":"Method 2 - Git‚Äã","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---git","content":"If you don't trust Method 1 (I get it!), you can download the repo and compile the plugin yourself! (1) Clone the repository to your local machine‚Äã Open up the terminalRoute to your desired directoryRun git clone https://github.com/JoelBrd/Socket info Unsure what the terminal is? Wonder how to route to a desired directory? Got no idea what git is? Check this video out, or strongly consider using Method 1 (2) Use Wally to download the dependencies‚Äã Socket uses Roact, Rodux, Roact-Rodux,Promise and Janitor! Download Wally onto your machineOpen ...\\Socket\\src\\Shared\\Libraries in the terminal Run the comamnd wally install (3) Use Rojo to sync the project onto a Roblox Studio place‚Äã Please see the Rojo Docs on how to do this (4) Compile the plugin‚Äã Select game.ServerScriptService.SocketPlugin and game.ServerScriptService.SocketPlugin.PluginFrameworkRight Click game.ServerScriptService.SocketPlugin -&gt; Save as Local PluginAfter selecting a name and saving, Socket should appear on your plugin toolbar! "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"What is Socket?‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#what-is-socket","content":"Watch a video explaining what Socket is! Socket is a Roblox plugin that allows us to easily run code in Roblox Studio. Why do I need Socket when I have the Command Line?‚Äã You can run code through the command line, but you're limited to this interface:  This interface is much nicer, don't you think?  Socket is a macro manager; we can pre-define code, and run it via the Run buttons on the Widget. There is functionality to run these macros via a keybind, we can define fields values for our macros to use and more. There are other tools out there that provide this macro manager functionality, so why use Socket? "},{"title":"Why Socket?‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#why-socket","content":"info The desire to create Socket came from wanting a plugin that could have the functionality of multiple plugins. You could just add multiple buttons to the plugin toolbar, but this doesn't scale well. Socket aims to solve this issue, and to be a diverse tool for power users. The name Socket came from the idea of real-world sockets, where you put a plug into a socket. You can have an extension cable that can have multiple plugs plugged in - word play off &quot;Plugin&quot;. "},{"title":"Organisation‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#organisation","content":"Socket allows you to organise your Macros into different groups, and easily view/access/run them. It mirrors the functionality of the Explorer tab with it's layout and ability to expand/collapse objects. You can also search through your Macros to find what you're looking for in an instant. "},{"title":"Customisation‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#customisation","content":"While the Socket plugin adheres to your Studio theme, you can customise each Group and Macro as well as general settings! NamesIcons (Text and ImageId)Colors (TextColor3 and ImageColor3)Sort OrderFieldsKeybindsFontDefault StateUI Scaling  "},{"title":"Uses ModuleScripts‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#uses-modulescripts","content":"The way you define Macros and add/remove/change them is via ModuleScripts! There is a game.ServerStorage.SocketPlugin directory where you can place multiple Macros and any utility ModuleScripts. Easy management of your Macros through both the Widget and Explorer tabReroute logic to Util files that multiple Macros can accessUse the Roblox Studio script editor to write your codeEasily share Macros between all team members on Team CreateSync your Macros via Rojo (!!!) "},{"title":"Ergonomics‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#ergonomics","content":"Want to give some instructions on how to use your Macro incase your distributing it, or plan to use it again? You can add a Description that can be easily viewed in 1 Click via the Widget. Whenever you make a change to a Macro, it will automatically update the Widget. If any changes break the integrity of the ModuleScript, you will be warned in the output window! It can be cumbersome to make changes whenever you want to alter the functionality of your Macro - Fields come to the rescue! You can define field values on the Widget that can then be read from instantly in your Macro Function "},{"title":"Automation‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#automation","content":"There is an obvious hint at automation with any kind of &quot;macro manager&quot;, but with Socket specifically: 1 Click to run any of your MacrosDefine a Keybind to run a Macro without using the Widget!Toggleable Macros to turn routines on/off as you please Toggleable Macros (See: MacroState)  -&gt;  "},{"title":"Server/Client Runners‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#serverclient-runners","content":"When playtesting, you have the option to run your Macros on the Server or Client. Super useful for checking Client -&gt; Server security.  "},{"title":"(v1.1.0) Local Macros‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#v110-local-macros","content":"You may have macros that you want to keep across different Roblox places. You could copy + paste the relevant ModuleScript across all places, or store it as a Local Macro! See LocalMacro "},{"title":"Luau","type":0,"sectionRef":"#","url":"docs/Luau","content":"Luau In v1.2.0, I created some boilerplate Luau types. This is immediately accessible when creating macros in Studio (use the Create Macro macro to see this). If developing in an IDE (e.g., VSCode) you will want to copy + paste the following code, and require it in your macro scripts to get the luau intellisense. This isn't ideal I realise, but this is plugin needs a fairly unconventional design to work as it does! export type Janitor = { Add: (object: any, methodName: boolean | string | nil, index: any?) -&gt; any, } export type InstanceUtil = { IntroduceInstance: (self: InstanceUtil, instance: Instance, dontSetWaypoint: boolean?) -&gt; nil, ClearInstance: (self: InstanceUtil, instance: Instance, doDestroy: boolean) -&gt; nil, } export type Logger = { MacroInfo: (self: Logger, macro: MacroDefinition, ...any) -&gt; nil, MacroWarn: (self: Logger, macro: MacroDefinition, ...any) -&gt; nil, } export type RaycastUtil = { RaycastMouse: (self: RaycastUtil, distance: number, raycastParams: RaycastParams?, checkAllCollisionGroups: boolean?) -&gt; RaycastResult, Raycast: ( self: RaycastUtil, origin: Vector3, direction: Vector3, distance: number, raycastParams: RaycastParams?, checkAllCollisionGroups: boolean? ) -&gt; RaycastResult, } export type MacroState = { FieldValues: { [string]: any }, -- Keys are FieldNames, Values are FieldValues IsRunning: boolean?, IsKeybindDisabled: boolean?, _Server: MacroState, _Client: MacroState, } export type MacroFieldTypeName = &quot;string&quot; | &quot;number&quot; | &quot;boolean&quot; | &quot;Color3&quot; | &quot;Vector3&quot; export type MacroField = { Type: MacroFieldTypeName, Name: string, IsRequired: boolean?, Validator: (value: any) -&gt; string | nil, } export type MacroDefinition = { Name: string, NameColor: Color3?, Icon: string?, IconColor: Color3?, Group: string?, GroupColor: Color3?, GroupIcon: string?, GroupIconColor: Color3?, Description: string?, LayoutOrder: number?, EnableAutomaticUndo: boolean?, IgnoreGameProcessedKeybinds: boolean?, AutoRun: boolean?, Keybind: { Enum.KeyCode }?, -- {} Fields: { MacroField }?, -- {} State: MacroState?, Disabled: boolean?, Function: (macro: PopulatedMacroDefinition, plugin: Plugin) -&gt; any, BindToClose: ((macro: PopulatedMacroDefinition, plugin: Plugin) -&gt; any)?, BindToOpen: ((macro: PopulatedMacroDefinition, plugin: Plugin) -&gt; any)?, } export type PopulatedMacroDefinition = MacroDefinition &amp; { Icon: string, Group: string, Description: string, LayoutOrder: number, EnableAutomaticUndo: boolean, IgnoreGameProcessedKeybinds: boolean, AutoRun: boolean, IsLocalMacro: boolean, Keybind: { Enum.KeyCode }, Fields: { MacroField }, FieldChanged: BindableEvent, State: MacroState, RunJanitor: Janitor, Disabled: boolean, GetFieldValue: (self: PopulatedMacroDefinition, fieldName: string) -&gt; any, ToggleIsRunning: (self: PopulatedMacroDefinition) -&gt; (), IsRunning: (self: PopulatedMacroDefinition) -&gt; boolean, } return {} ","keywords":""},{"title":"Adding Your First Macro","type":0,"sectionRef":"#","url":"docs/YourFirstMacro","content":"","keywords":""},{"title":"Creating a new Macro‚Äã","type":1,"pageTitle":"Adding Your First Macro","url":"docs/YourFirstMacro#creating-a-new-macro","content":"Let's make use of one of our Core Macros, Create Macro to create your first macro This creates a ModuleScript in the SocketPlugin.Macros directory info You can create folders in this directory to help organise your Macros; but the Group of a Macro is defined within the ModuleScript itself You'll get a ModuleScript with a Source similar to: --- -- Macro --- -------------------------------------------------- -- Dependencies local ServerStorage = game:GetService(&quot;ServerStorage&quot;) local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) -------------------------------------------------- -- Members local macroDefinition = { Name = &quot;%s&quot;, Group = &quot;Macros&quot;, Icon = &quot;%s&quot;, Description = &quot;%s&quot;, } macroDefinition.Function = function(macro, plugin) Logger:MacroInfo(macro, (&quot;Hello %s!&quot;):format(macro.Name)) --[[ ... Your Logic Here ... ]] end return macroDefinition  You'll notice we're returning a table with key/value pairs. For a full breakdown of what is on offer, and what they each do, see MacroDefinition. There are 2 required key/value pairs: NameFunction Everything else is optional, or will be populated with a default value. tip Try adding + configuring some fields, and see how the Widget updates! Keep an eye on the output window incase there are any issues with your MacroDefinition. "},{"title":"Creating our code‚Äã","type":1,"pageTitle":"Adding Your First Macro","url":"docs/YourFirstMacro#creating-our-code","content":"We now have a fresh Macro, and have played around with how it appears on the Widget. Lets take a look at the tools we have when defining our Function "},{"title":"Parameters‚Äã","type":1,"pageTitle":"Adding Your First Macro","url":"docs/YourFirstMacro#parameters","content":"Function gets passed 2 parameters; macro: MacroDefinition, plugin: Plugin. macro is our MacroDefinition. It is important we reference macro inside our functions, and not macroDefinition. Changes are made outside the scope of the ModuleScript (e.g., if we change a Field value on the Widget, this is written to the macro variable and not macroDefinition)plugin is the actual Plugin object that Socket is under; this is passed for special use cases, as the Plugin object has unique API "},{"title":"Logging‚Äã","type":1,"pageTitle":"Adding Your First Macro","url":"docs/YourFirstMacro#logging","content":"You'll notice in the template Macro that gets created, a required Logger file. This gives us access to Logger:MacroInfo(macro, &quot;Hello!&quot;) and Logger:MacroWarn(macro, &quot;Uh Oh!&quot;) This is just a nice way to print to the output, and show the Macro scope it came from. This is the same API used for when Socket detects an issue with a Macro and wants to inform the user (e.g., a required Field is missing its value) "},{"title":"Using the macro Parameter‚Äã","type":1,"pageTitle":"Adding Your First Macro","url":"docs/YourFirstMacro#using-the-macro-parameter","content":"You can reference any members of macro (see MacroDefinition). One of the most useful members is macro.State (see MacroState). Let's take a quick look what that gives us access to: macro.State.IsRunning &amp; macro:ToggleIsRunning()‚Äã We may want to have a Macro that has a toggleable routine; aka we can turn it on and off. We can change macro.State.IsRunning to keep track of the macro being on or off. We can toggle this using ToggleIsRunning and read it via IsRunning. These methods are sugar for manipulating values in macro macro.State.FieldValues‚Äã A strength of Socket is being able to declare values on the fly to be used in our Macros. These are easily accessible on the Widget, but we then ofcourse need to reference them in our Function. macro.State.FieldValues is where the declared values of fields exist. If we have declared a field such as: { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; } } }  We can access the value via macro:GetFieldValue(&quot;Amount&quot;) (which is sugar for macro.State.FieldValues.Amount) Note that amount may not exist, so we can either: Run this check in our FunctionDo  { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; } } }  If IsRequired=true, we will get a Logger:MacroWarn warning in our output if we run the macro and we have not declared a value for the Field. We can assume it exists in our Function now! A nice trick we can do is if we want to declare a default value for a Field, we can mirror the following structure in our MacroDefinition { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; } } State = { FieldValues = { Amount = 1; } } }  We may also have an input field that has some specific requirements (e.g., for an Amount value, we probably want a positive integer!). We can write these checks in our Function ofcourse - a cleaner option is this: { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; Validator = function(value) local hasDecimalComponent = math.floor(value) ~= value local isLessThanZero = value &lt;= 0 if hasDecimalComponent or isLessThanZero then return &quot;Must be a positive non-zero integer&quot; end end } } }  If there is an issue, return a string detailing the issue. This will be written to the output, along with the context of the Field (Macro, Field Name/Type/Value) "},{"title":"BindToClose‚Äã","type":1,"pageTitle":"Adding Your First Macro","url":"docs/YourFirstMacro#bindtoclose","content":"Imagine we have a Macro that is running routines (macro.State.IsRunning=true), but we then delete the ModuleScript for that Macro, or we close the Plugin? We could still have code running that would've normally been stopped by toggling the Macro. This is where BindToClose comes in. Example:  local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- MacroDefinition that, when running, will print the time since the last frame local macroDefinition = { -- ... Function = function(macro, plugin) -- Toggle running state macro:ToggleIsRunning() -- Get Variables local isRunning = macro:IsRunning() if isRunning then macro.State.HeartbeatConnection = Heartbeat:Connect(function(dt) Logger:MacroInfo(macro, (&quot;dt: %f&quot;)) end) elseif macro.State.HeartbeatConnection then macro.State.HeartbeatConnection:Disconnect() macro.State.HeartbeatConnection = nil end end; BindToClose = function(macro, plugin) if macro.State.HeartbeatConnection then macro.State.HeartbeatConnection:Disconnect() macro.State.HeartbeatConnection = nil end end; -- ... }  In the above situation, toggling IsRunning from outside the scope of Function will still cause routines to keep running! BindToClose saves the day by ensuring HeartbeatConnection is disconnected. tip Naturally when BindToClose is called by Socket, we also toggle IsRunning=false - so if you hade a routine like: while macro.State.IsRunning do -- ... end The loop would stop and does not require a BindToClose function. We also cleanup the RunJanitor when BindToClose is called. We can pass any Instances, or other routines, to the RunJanitor to be cleaned up when the Macro stops running. Check out the API here The above example was to demonstrate the functionality of BindToClose; a much cleaner structure would be:  local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- MacroDefinition that, when running, will print the time since the last frame local macroDefinition = { -- ... Function = function(macro, plugin) -- Toggle running state macro:ToggleIsRunning() -- RETURN: Not running if not macro:IsRunning() then return end -- Setup Loop macro.RunJanitor:Add(Heartbeat:Connect(function(dt) Logger:MacroInfo(macro, (&quot;dt: %f&quot;)) end)) end -- ... }  "},{"title":"Examples","type":0,"sectionRef":"#","url":"docs/Examples","content":"","keywords":""},{"title":"Example 1 | Midas Touch Macro‚Äã","type":1,"pageTitle":"Examples","url":"docs/Examples#example-1--midas-touch-macro","content":"Lets go through an example here by creating a Macro that makes parts look golden. "},{"title":"Create the Macro‚Äã","type":1,"pageTitle":"Examples","url":"docs/Examples#create-the-macro","content":"We'll start off by placing a ModuleScript at game.ServerStorage.SocketPlugin.Macros.MidasTouch: --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local ServerStorage = game:GetService(&quot;ServerStorage&quot;) local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) -------------------------------------------------- -- Members local macroDefinition = { Group = &quot;Golden&quot;, Name = &quot;Midas Touch&quot;, Description = &quot;Makes parts gold&quot;, } macroDefinition.Function = function(macro, plugin) Logger:MacroInfo(macro, &quot;I command you to make parts golden!&quot;) end return macroDefinition  Result:  "},{"title":"Make it pretty‚Äã","type":1,"pageTitle":"Examples","url":"docs/Examples#make-it-pretty","content":"This is looking a touch bland on our Widget, lets juice it up a bit. local macroDefinition = { Group = &quot;Golden&quot;, GroupColor = Color3.fromRGB(255, 180, 0), GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Makes parts gold&quot;, }  Better!  "},{"title":"v1‚Äã","type":1,"pageTitle":"Examples","url":"docs/Examples#v1","content":"The Macro currently doesn't do anything, other than print a silly message to the output window. Lets make it so when we run the Macro, it will make any parts that we have selected turn golden: --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members local macroDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, } macroDefinition.Function = function(macro, plugin) -- Get our selected instances, and filter out any non-BaseParts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) then if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = COLOR_GOLD part.Material = Enum.Material.Foil end -- Log Logger:MacroInfo(macro, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end return macroDefinition  Cool!  "},{"title":"v2‚Äã","type":1,"pageTitle":"Examples","url":"docs/Examples#v2","content":"Automatic Undo‚Äã v1 was all well and good, but what if I accidentally gold-ify a part that I didn't want to? We need to setup ChangeHistoryService waypoints to implement this, or we can simply do: { -- ... EnableAutomaticUndo = true -- ... }  More colors‚Äã I'm also not super happy with it always being the same color; lets add 2 color fields that we will uniformly interpolate between. { -- ... Fields = { { Name = &quot;ColorA&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;ColorB&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, } -- ... }   Real time‚Äã Finally, I don't want to have to click Run, or use a Keybind, to make a part gold. I want to Make the Macro toggleableWhenever the Macro is running, any parts I select will turn to gold in real time.Define routines so they'll get cleaned up safely Lets write some code to make this happen.. --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members local macroDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, EnableAutomaticUndo = true, Fields = { { Name = &quot;ColorA&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;ColorB&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, }, } macroDefinition.Function = function(macro, plugin) -- Toggle running macro:ToggleIsRunning() -- RETURN: Not running if not macro:IsRunning() then return end -- Get Variables local colorA = macro:GetFieldValue(&quot;ColorA&quot;) local colorB = macro:GetFieldValue(&quot;ColorB&quot;) -- Setup Loop macro.RunJanitor:Add(Selection.SelectionChanged:Connect(function() -- Get our selected instances, and filter out any non-parts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) do if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = colorA:Lerp(colorB, math.random()) part.Material = Enum.Material.Foil end if #parts &gt; 0 then Logger:MacroInfo(macro, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end end)) end return macroDefinition  Fantastic &lt;3  "}]