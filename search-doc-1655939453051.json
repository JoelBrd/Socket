[{"title":"InstanceUtil","type":0,"sectionRef":"#","url":"api/InstanceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#functions","content":" "},{"title":"IntroduceInstance​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#IntroduceInstance","content":"&lt;/&gt; InstanceUtil:IntroduceInstance( instance: Instance , dontSetWaypoint: boolean | nil ) → () Brings an instance into the workspace in the context of Socket and the user calling this function. By default, sets a ChangeHistoryService waypoint.  "},{"title":"ClearInstance​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#ClearInstance","content":"&lt;/&gt; InstanceUtil:ClearInstance( instance: Instance , doDestroy: boolean ) → () Clears an instance from our context of Socket and the user calling this function. Should be an instance that was introduced via IntroduceInstance "},{"title":"Promise","type":0,"sectionRef":"#","url":"api/Promise","content":"On this page Promise See Promise","keywords":""},{"title":"Janitor","type":0,"sectionRef":"#","url":"api/Janitor","content":"On this page Janitor See Janitor","keywords":""},{"title":"Logger","type":0,"sectionRef":"#","url":"api/Logger","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Logger","url":"api/Logger#functions","content":" "},{"title":"PlugInfo​","type":1,"pageTitle":"Logger","url":"api/Logger#PlugInfo","content":"&lt;/&gt; Logger:PlugInfo( plug: PlugDefinition, ...: any ) → () For showing general information to the output  "},{"title":"PlugWarn​","type":1,"pageTitle":"Logger","url":"api/Logger#PlugWarn","content":"&lt;/&gt; Logger:PlugWarn( plug: PlugDefinition, ...: any ) → () For informing the user that an issue with a plug has occured "},{"title":"RaycastUtil","type":0,"sectionRef":"#","url":"api/RaycastUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"RaycastUtil","url":"api/RaycastUtil#functions","content":" "},{"title":"RaycastMouse​","type":1,"pageTitle":"RaycastUtil","url":"api/RaycastUtil#RaycastMouse","content":"&lt;/&gt; RaycastUtil:RaycastMouse( distance: number, raycastParams: RaycastParams | nil, checkAllCollisionGroups: boolean | nil ) → () Sends a raycast from our camera to the point our mouse is at in the world. checkAllCollisionGroups=true will make sure we raycast against parts that don't collide with the &quot;Default&quot; Collision Group (see the &quot;.Locked&quot; plug)  "},{"title":"Raycast​","type":1,"pageTitle":"RaycastUtil","url":"api/RaycastUtil#Raycast","content":"&lt;/&gt; RaycastUtil:Raycast( origin: Vector3 , direction: Vector3 , distance: number, raycastParams: RaycastParams | nil, checkAllCollisionGroups: boolean | nil ) → () Does a bog standard raycast. checkAllCollisionGroups=true will make sure we raycast against parts that don't collide with the &quot;Default&quot; Collision Group (see the &quot;.Locked&quot; plug) "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method 1 - Plugin​","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1---plugin","content":"Download the plugin here via Roblox "},{"title":"Method 2 - Git​","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---git","content":"If you don't trust Method 1 (I get it!), you can download the repo and compile the plugin yourself! (1) Clone the repository to your local machine​ Open up the command terminalRoute to your desired directory via cd &lt;some directory&gt;Use git clone https://github.com/JoelBrd/Socket info No idea what git is? Check this video out, or strongly consider using Method 1 (2) Use Rojo to sync the project onto a Roblox Studio place​ Please see the Rojo Docs on how to do this (3) Compile the plugin​ Select game.ServerScriptService.SocketPlugin and game.ServerScriptService.SocketPlugin.PluginFrameworkRight Click -&gt; Save as Local PluginAfter selecting a name and saving, Socket will appear on your plugin toolbar! "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Content​","type":1,"pageTitle":"Introduction","url":"docs/intro#content","content":"Installation guide "},{"title":"What is Socket?​","type":1,"pageTitle":"Introduction","url":"docs/intro#what-is-socket","content":"Socket is a Roblox plugin that allows us to easily run code in Roblox Studio. Why do I need Socket when I have the Command Line?​ You can run code through the command line, but you're limited to this interface:  This interface is much nicer, don't you think?  Socket is a macro manager; we can pre-define code, and run it via the Run buttons on the Widget. There is functionality to run these &quot;macros&quot; via a keybind, we can define fields values for our macros to use and more. There are other tools out there that provide this &quot;macro manager&quot; functionality, so why use Socket? "},{"title":"Why Socket?​","type":1,"pageTitle":"Introduction","url":"docs/intro#why-socket","content":"info The desire to create Socket came from wanting a plugin that could have the functionality of multiple plugins. You could just add multiple buttons to the plugin toolbar, but this doesn't scale well. Introducing Socket! We call individual macros &quot;Plugs&quot;, as a Plug will Plug-in to a Socket IRL "},{"title":"Organisation​","type":1,"pageTitle":"Introduction","url":"docs/intro#organisation","content":"Socket allows you to organise your Plugs into different groups, and easily view/access/run them. It mirrors the functionality of the Explorer tab with it's layout and ability to expand/collapse objects. You can also search through your Plugs to find what you're looking for in an instant. "},{"title":"Customisation​","type":1,"pageTitle":"Introduction","url":"docs/intro#customisation","content":"While the Socket plugin adheres to your Studio theme, you can customise each Group and Plug as well as general settings! NamesIcons (Text and ImageId)Colors (TextColor3 and ImageColor3)Sort OrderFieldsKeybindsFontDefault StateUI Scaling   "},{"title":"Uses ModuleScripts​","type":1,"pageTitle":"Introduction","url":"docs/intro#uses-modulescripts","content":"The way you define Plugs and add/remove/change them is via ModuleScripts! There is a game.ServerStorage.SocketPlugin directory where you can place multiple Plugs and any utility ModuleScripts. Easy management of your Plugs through both the Widget and Explorer tabReroute logic to Util files that multiple Plugs can accessUse the Roblox Studio script editor to write your codeEasily share Plugs between all team members on Team CreateSync your Plugs via Rojo (!!!) "},{"title":"Ergonomics​","type":1,"pageTitle":"Introduction","url":"docs/intro#ergonomics","content":"Want to give some instructions on how to use your Plug incase your distributing it, or plan to use it 2 weeks from now? You can add a Description that can be easily viewed in 1 Click via the Widget. Whenever you make a change to a Plug, it will automatically update the Widget. If any changes break the integrity of the ModuleScript, you will be warned! It can be cumbersome to make changes whenever you want to alter the functionality of your Plug - Fields come to the rescue! You can define field values on the Widget that can then be read from instantly in your Plug Function "},{"title":"Automation​","type":1,"pageTitle":"Introduction","url":"docs/intro#automation","content":"There is an obvious hint at automation with any kind of &quot;macro manager&quot;, but with Socket specifically: 1 Click to run any of your PlugsDefine a Keybind to run a Plug without using the Widget!Toggleable Plugs to turn routines on/off as you please Toggleable Plugs (See: PlugState)  -&gt;  "},{"title":"Server/Client Runners​","type":1,"pageTitle":"Introduction","url":"docs/intro#serverclient-runners","content":"When playtesting, you have the option to run your Plugs on the Server or Client. Super useful for checking Client -&gt; Server security.  "},{"title":"PlugField","type":0,"sectionRef":"#","url":"api/PlugField","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"PlugField","url":"api/PlugField#properties","content":" "},{"title":"Type​","type":1,"pageTitle":"PlugField","url":"api/PlugField#Type","content":"Required &lt;/&gt; PlugField.Type: PlugFieldType The type of data this field will take (e.g., &quot;number&quot;)  "},{"title":"Name​","type":1,"pageTitle":"PlugField","url":"api/PlugField#Name","content":"Required &lt;/&gt; PlugField.Name: string The name of this field. This is the same string used to reference this field within a plug.  "},{"title":"IsRequired​","type":1,"pageTitle":"PlugField","url":"api/PlugField#IsRequired","content":"&lt;/&gt; PlugField.IsRequired: boolean If true, the plug will not run + produce a PlugWarn in the output if a value has not been defined. "},{"title":"Functions​","type":1,"pageTitle":"PlugField","url":"api/PlugField#functions","content":" "},{"title":"Validator​","type":1,"pageTitle":"PlugField","url":"api/PlugField#Validator","content":"&lt;/&gt; PlugField.Validator(value: any) → string We can define a Validator function to run our field value by when we run the plug. If there is an issue, we have Validator return a string detailing the issue. If everything is OK, return nil. An example use case is if we have a &quot;number&quot; field, but we want to make sure it is non-negative. { Name = &quot;Height&quot;; PlugFieldType = &quot;number&quot;; Validator = function(someNumber) if someNumber &lt; 0 then return (&quot;Must be non-negative. Got: %d&quot;):format(someNumber) end end }  "},{"title":"SocketSettings","type":0,"sectionRef":"#","url":"api/SocketSettings","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#properties","content":" "},{"title":"Font​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#Font","content":"&lt;/&gt; SocketSettings.Font: Enum.Font The Font used on the widget. Defaults to Enum.Font.Highway  "},{"title":"UIScale​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#UIScale","content":"&lt;/&gt; SocketSettings.UIScale: number This can be tweaked to change the scaling of the UI. Useful for users on a high DPI monitor, or a user that benefits from larger text. Defaults to 1  "},{"title":"OpenFieldsByDefault​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#OpenFieldsByDefault","content":"&lt;/&gt; SocketSettings.OpenFieldsByDefault: boolean The widget uses toggle arrows to show/hide information. If true, the &quot;Fields&quot; sections inside plugs will be open by default. Just saves the user another click. Defaults to true  "},{"title":"GroupMatchingIcons​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#GroupMatchingIcons","content":"&lt;/&gt; SocketSettings.GroupMatchingIcons: boolean Plugs are sorted alphabetically on the widget. If this is true, this will be superseded by making sure Plugs with the same .Icon are next to one another on the widget. Defaults to true  "},{"title":"IgnoreGameProcessedKeybinds​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#IgnoreGameProcessedKeybinds","content":"&lt;/&gt; SocketSettings.IgnoreGameProcessedKeybinds: boolean If true, will not discard UserInputService#InputBegan events where gameProcessed=true. Defaults to false  "},{"title":"EnableSocketPlugs​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#EnableSocketPlugs","content":"&lt;/&gt; SocketSettings.EnableSocketPlugs: boolean Declares if Socket should automatically add its pre-packaged Plugs. If false, and you delete all the default Plugs, they will not reappear when you restart Socket. Defaults to true  "},{"title":"EnableSocketPlugsOverwrite​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#EnableSocketPlugsOverwrite","content":"&lt;/&gt; SocketSettings.EnableSocketPlugsOverwrite: boolean Slightly softer version of EnableSocketPlugs. By default, Socket will delete+add its pre-packaged Plugs on startup. This means that any user-made changes to the ModuleScripts will be overwritten. Set this to false to disable this behaviour. Defaults to true  "},{"title":"EnableAutoRun​","type":1,"pageTitle":"SocketSettings","url":"api/SocketSettings#EnableAutoRun","content":"&lt;/&gt; SocketSettings.EnableAutoRun: boolean If false, will ignore the .AutoRun member in any PlugDefinition Defaults to true "},{"title":"Adding Your First Plug","type":0,"sectionRef":"#","url":"docs/YourFirstPlug","content":"","keywords":""},{"title":"Creating a new Plug​","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#creating-a-new-plug","content":"Let's make use of one of our Core Plugs, Create Plug to create your first plug This creates a ModuleScript in the SocketPlugin.Plugs directory info You can create folders in this directory to help organise your Plugs; but the Group of a Plug is defined within the ModuleScript itself You'll get a ModuleScript with a Source similar to: --- ---Plug Template --- -------------------------------------------------- -- Dependencies local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;%s&quot;, ---@type string GroupColor = nil, ---@type Color3 GroupIcon = nil, ---@type string GroupIconColor = nil, ---@type Color3 Name = &quot;%s&quot;, NameColor = nil, ---@type Color3 Icon = &quot;%s&quot;, IconColor = nil, ---@type Color3 Description = &quot;%s&quot;, ---@type string EnableAutomaticUndo = false, ---@type boolean AutoRun = false, ---@type boolean Keybind = {}, ---@type Enum.KeyCode[] Fields = {}, ---@type PlugField[] Function = nil, ---@type fun(plug:PlugDefinition, plugin:Plugin) } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) Logger:PlugInfo(plug, (&quot;Hello, from %s!&quot;):format(plug.Name)) end return plugDefinition Copy You'll notice we're returning a table with a bunch of key/value pairs. For a full breakdown of these, and what they each do, see PlugDefinition. There are 2 required key/value pairs: NameFunction Everything else is optional, or will be populated with a default value. tip Try editing some of these fields, and see how the Widget updates! Keep an eye on the output window incase there are any issues with your PlugDefinition. "},{"title":"Creating our code​","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#creating-our-code","content":"We now have a fresh Plug, and have played around with how it appears on the Widget. Lets take a look at the tools we have when defining our Function "},{"title":"Parameters​","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#parameters","content":"Function gets passed 2 parameters; plug: PlugDefinition, plugin: [Plugin]. plug is our PlugDefinition. It is important we reference plug, and not plugDefinition. Changes are made outside the scope of the ModuleScript (e.g., if we change a Field value on the Widget, this is written to plug and not plugDefinition)plugin is the actual Plugin object that Socket is under; this is passed for special use cases, as the Plugin object has unique API "},{"title":"Logging​","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#logging","content":"You'll notice in the template Plug that gets created, a required Logger file. This gives us access to: Logger:PlugInfo(plug, &quot;Hello!&quot;) -- &lt;==&gt; print((&quot;[%s %s] %s&quot;):format(plug.Icon or &quot;&quot;, plug.Name, &quot;Hello!&quot;)) Logger:PlugWarn(plug, &quot;Uh Oh!&quot;) -- &lt;==&gt; warn((&quot;[%s %s] %s&quot;):format(plug.Icon or &quot;&quot;, plug.Name, &quot;Hello!&quot;)) Copy This is just a nice way to print to the output, and show the Plug scope it came from. This is the same API used for when Socket detects an issue with a Plug and wants to inform the user (e.g., a required Field is missing its value) "},{"title":"Using plug Parameter​","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#using-plug-parameter","content":"You can reference any members of plug (see PlugDefinition) - most notably plug.State (see PlugState) plug.State.IsRunning &amp; plug:ToggleIsRunning()​ We may want to have a Plug that has a toggleable routine; aka we can turn it on and off. We can change plug.State.IsRunning to indicate on the widget if the plug is running or not. Check out the API here plug.State.FieldValues​ This is where the declared values of fields exist. If we have declared a field such as: { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; } } } Copy We can access the value via local amount = plug.State.FieldValues.Amount - or more nicely local amount = plug:GetFieldValue(&quot;Amount&quot;)Note that amount may not exist, so we can either: Run this check in our FunctionDo  { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; } } } Copy If IsRequired=true, we will get a Logger:PlugWarn in our output if we run the plug and we have not declared a value for the Field. We can assume it exists in our Function now! A nice trick we can do is if we want to declare a default value for a Field, we can mirror the following structure in our PlugDefinition { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; } } State = { FieldValues = { Amount = 1; } } } Copy "},{"title":"BindToClose​","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#bindtoclose","content":"Imagine we have a Plug that is running routines (IsRunning=true), but we then delete the ModuleScript for that Plug, or we close the Plugin? We could still have code running that would've normally been stopped by toggling the Plug. This is where BindToClose comes in. Example:  local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- PlugDefinition that, when running, will print the time since the last frame local plugDefinition = { -- ... Fields = { { Name = &quot;Timer&quot;; Type = &quot;number&quot;; IsRequired = true; } } State = { IsRunning = false } Function = function(plug, plugin) -- Toggle running state plug.State.IsRunning = not plug.State.IsRunning -- Get Variables local timer = plug.State.FieldValues.Timer local isRunning = plug.State.IsRunning if isRunning then plug.State.HeartbeatConnection = Heartbeat:Connect(function(dt) Logger:PlugInfo(plug, (&quot;dt: %f&quot;)) end) elseif plug.State.HeartbeatConnection then plug.State.HeartbeatConnection:Disconnect() plug.State.HeartbeatConnection = nil end end BindToClose = function(plug, plugin) if plug.State.HeartbeatConnection then plug.State.HeartbeatConnection:Disconnect() plug.State.HeartbeatConnection = nil end end -- ... } Copy In the above situation, toggling IsRunning from outside the scope of Function will still cause routines to keep running! BindToClose saves the day by ensuring HeartbeatConnection is disconnected. tip Naturally when BindToClose is called by Socket, we also toggle IsRunning=false - so if you hade a routine like: while plug.State.IsRunning do -- ... end Copy The loop would stop and does not require a BindToClose function. We also cleanup the RunJanitor when BindToClose is called. Check out the API here The above example was to demonstrate the functionality of BindToClose; a much cleaner structure would be:  local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- PlugDefinition that, when running, will print the time since the last frame local plugDefinition = { -- ... Fields = { { Name = &quot;Timer&quot;; Type = &quot;number&quot;; IsRequired = true; } } State = { IsRunning = false } Function = function(plug, plugin) -- Toggle running state plug:ToggleIsRunning() -- RETURN: Not running if not plug.State.IsRunning then return end -- Get Variables local timer = plug.State.FieldValues.Timer -- Setup Loop plug.RunJanitor:Add(Heartbeat:Connect(function(dt) Logger:PlugInfo(plug, (&quot;dt: %f&quot;)) end)) end -- ... } Copy "},{"title":"Example 1 | Midas Touch Plug","type":0,"sectionRef":"#","url":"docs/Examples","content":"","keywords":""},{"title":"Create the Plug​","type":1,"pageTitle":"Example 1 | Midas Touch Plug","url":"docs/Examples#create-the-plug","content":"We'll start off by placing a ModuleScript at game.ServerStorage.SocketPlugin.Plugs.MidasTouch: --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, Name = &quot;Midas Touch&quot;, Description = &quot;Makes parts gold&quot;, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) Logger:PlugInfo(plug, &quot;I command you to make parts golden!&quot;) end return plugDefinition Copy Result:  "},{"title":"Make it pretty​","type":1,"pageTitle":"Example 1 | Midas Touch Plug","url":"docs/Examples#make-it-pretty","content":"This is looking a touch bland on our Widget, lets juice it up a bit. local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = Color3.fromRGB(255, 180, 0), GroupIcon = &quot;👑&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;🤏&quot;; Description = &quot;Makes parts gold&quot;, } Copy Better!  "},{"title":"v1​","type":1,"pageTitle":"Example 1 | Midas Touch Plug","url":"docs/Examples#v1","content":"The Plug currently doesn't do anything, other than print a silly message to the output window. Lets make it so when we run the Plug, it will make any parts that we have selected turn golden: --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;👑&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;🤏&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) -- Get our selected instances, and filter out any non-parts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) then if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = COLOR_GOLD part.Material = Enum.Material.Foil end Logger:PlugInfo(plug, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end return plugDefinition Copy Cool!  "},{"title":"v2​","type":1,"pageTitle":"Example 1 | Midas Touch Plug","url":"docs/Examples#v2","content":"Automatic Undo​ v1 was all well and good, but what if I accidentally gold-ify a part that I didn't want to? We need to setup ChangeHistoryService waypoints to implement this, or we can simply do: { -- ... EnableAutomaticUndo = true -- ... } Copy More colors​ I'm also not super happy with it always being the same color; lets add 2 color fields that we will uniformly interpolate between. { Fields = { { Name = &quot;ColorA&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;ColorB&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, } } Copy  Real time​ Finally, I don't want to have to click Run, or use a Keybind, to make a part gold. I want to Make the Plug toggleableWhenever the Plug is running, any parts I select will turn to gold in real time.Define routines so they'll get cleaned up safely Lets write some code to make this happen.. --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;👑&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;🤏&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, EnableAutomaticUndo = true, Fields = { { Name = &quot;ColorA&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;ColorB&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, }, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) -- Toggle running plug:ToggleIsRunning() -- RETURN: Not running if not plug.State.IsRunning then return end -- Get Variables local colorA = plug:GetFieldValue(&quot;ColorA&quot;) local colorB = plug:GetFieldValue(&quot;ColorB&quot;) -- Setup Loop plug.RunJanitor:Add(Selection.SelectionChanged:Connect(function() -- Get our selected instances, and filter out any non-parts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) do if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = colorA:Lerp(colorB, math.random()) part.Material = Enum.Material.Foil end if #parts &gt; 0 then Logger:PlugInfo(plug, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end end)) end return plugDefinition Copy Fantastic &lt;3  "},{"title":"PlugDefinition","type":0,"sectionRef":"#","url":"api/PlugDefinition","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#types","content":" "},{"title":"PlugState​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#PlugState","content":"&lt;/&gt; interface PlugState { FieldValues: table&lt;PlugField.Name,any&gt;-- Where we can read the values in our fields from IsRunning: boolean | nil-- Use this variable to toggle the state of a Plug (updates the UI) _Server: PlugState-- Socket-only (used for communcicating Server/Client in Accurate Play Solo) _Client: PlugState-- Socket-only (used for communcicating Server/Client in Accurate Play Solo) } A table to store a plug's &quot;State&quot;. Socket writes some stuff here, but feel free to use this for whatever you need. If you overwrite any keys that Socket uses (fields defined here), expect mayhem and tears! "},{"title":"Properties​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#properties","content":" "},{"title":"Name​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Name","content":"Required &lt;/&gt; PlugDefinition.Name: string Declares the name that will appear on the Widget for the Plug. caution Longer names will be less readable on the Widget, depending on a user's resolution  "},{"title":"NameColor​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#NameColor","content":"Populated &lt;/&gt; PlugDefinition.NameColor: Color3  Give your Plug a pretty color on the Widget! Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Icon​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Icon","content":"Populated &lt;/&gt; PlugDefinition.Icon: string Defines an icon to put alongside the Name of the Plug. This can either be Text (e.g., Emoji) or an ImageId. ImageIds are recognised by the string containing rbxassetid { Icon = &quot;📂&quot; -- Good Icon = &quot;My Icon&quot; -- Probably too long, but good Icon = &quot;&quot; -- Bit boring, but good Icon = &quot;rbxassetid://9553550332&quot; -- Good ImageId Icon = &quot;https://www.roblox.com/library/9553550338/&quot; -- Bad ImageId (Website) Icon = &quot;http://www.roblox.com/asset/?id=9553550332&quot; -- Bad ImageId (Decal) } Defaults to &quot;❓&quot;  "},{"title":"IconColor​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#IconColor","content":"Populated &lt;/&gt; PlugDefinition.IconColor: Color3  Give your Plug icon a pretty color on the Widget! Applies to TextColor3 or ImageColor3, depending on Icon input Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Group​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Group","content":"Populated &lt;/&gt; PlugDefinition.Group: string The group that the Plug belongs to. Any plugs with a matching Group value will be grouped together on the Widget Defaults to &quot;No Group&quot;  "},{"title":"GroupColor​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GroupColor","content":"Populated &lt;/&gt; PlugDefinition.GroupColor: Color3  Give the Group text a pretty color on the Widget! If you have multiple Plugs under the same Group, GroupColor need only be defined on a singular PlugDefinition. Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"GroupIcon​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GroupIcon","content":"Populated &lt;/&gt; PlugDefinition.GroupIcon: string Defines an icon to put alongside the name of the Group the Plug is under. If you have multiple Plugs under the same Group, GroupIcon need only be defined on a singular PlugDefinition This can either be Text (e.g., Emoji) or an ImageId. ImageIds are recognised by the string containing rbxassetid { Icon = &quot;📂&quot; -- Good Icon = &quot;My Icon&quot; -- Probably too long, but good Icon = &quot;&quot; -- Bit boring, but good Icon = &quot;rbxassetid://9553550332&quot; -- Good ImageId Icon = &quot;https://www.roblox.com/library/9553550338/&quot; -- Bad ImageId (Website) Icon = &quot;http://www.roblox.com/asset/?id=9553550332&quot; -- Bad ImageId (Decal) } Defaults to &quot;❓&quot;  "},{"title":"GroupIconColor​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GroupIconColor","content":"Populated &lt;/&gt; PlugDefinition.GroupIconColor: Color3  Give your Plug icon a pretty color on the Widget! Applies to TextColor3 or ImageColor3, depending on Icon input. If you have multiple Plugs under the same Group, GroupIconColor need only be defined on a singular PlugDefinition Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Description​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Description","content":"Populated &lt;/&gt; PlugDefinition.Description: string Any and all information pertaining to this specific Plug. This can be as long as you like as it appears in the output. { Description = &quot;Plug Description Line 1\\nPlug Description Line 2&quot; } Output: ================ Plug Name (Plug Group) | DESCRIPTION ================ Plug Description Line 1 Plug Description Line 2 ================ Plug Name (Plug Group) | DESCRIPTION ================ Defaults to &quot;No Description&quot;  "},{"title":"EnableAutomaticUndo​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#EnableAutomaticUndo","content":"Populated &lt;/&gt; PlugDefinition.EnableAutomaticUndo: boolean If true, will automatically setup ChangeHistoryService waypoints before and after running the Plug's Function. AKA, any changes to studio that your Plug makes, you can undo with Ctrl+Z or equivalent. You can obviously set this to false (or don't declare the field) if you want to write your own implementation. tip When you run &quot;Undo&quot; in Studio, it will undo the last change under the DataModel (game). If, for example, your Plug just prints to the output (and doesn't make any changes to the DataModel) it will undo the last change unrelated to your Plug Defaults to false  "},{"title":"IgnoreGameProcessedKeybinds​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#IgnoreGameProcessedKeybinds","content":"Populated &lt;/&gt; PlugDefinition.IgnoreGameProcessedKeybinds: boolean Socket uses UserInputService#InputBegan for detecting keybinds. game:GetService(&quot;UserInputService&quot;).InputBegan:Connect(function(inputObject, gameProcessedEvent) if gameProcessedEvent and not IgnoreGameProcessedKeybinds then return end ... end) Defaults to false  "},{"title":"AutoRun​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#AutoRun","content":"Populated &lt;/&gt; PlugDefinition.AutoRun: boolean If true, plug.Function will be called when Socket starts. Useful if there is a plug you want to run on startup. Defaults to false  "},{"title":"Keybind​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Keybind","content":"Populated &lt;/&gt; PlugDefinition.Keybind: {Enum.KeyCode} An array of Enum.KeyCode that can trigger the Plug to run. { Keybind = { Enum.KeyCode.LeftControl, Enum.KeyCode.J } } tip Will not work if any of the inputs have gameProcessedEvent set to true. See: UserInputService To disable this, see [TODO] Defaults to {}  "},{"title":"Fields​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Fields","content":"Populated &lt;/&gt; PlugDefinition.Fields: {PlugField} An array of PlugField, which define the different fields the Plug has. The order they are defined is the order they will appear on the widget. { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; }, { Name = &quot;Title&quot;; Type = &quot;string&quot;; } } } Defaults to {}  "},{"title":"FieldChanged​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#FieldChanged","content":"Read-Only &lt;/&gt; PlugDefinition.FieldChanged: BindableEvent  A BindableEvent to listen to field values being changed on the UI! plug.FieldChanged.Event:Connect(function(fieldName, fieldValue) print(plug:GetFieldValue(fieldName) == fieldValue) end) -- Output: true Most cases it will suffice to just read plug:GetFieldValue(fieldName) as and when you need a field value. But sometimes you may want to re-run routines after a field value change.  "},{"title":"State​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#State","content":"Populated &lt;/&gt; PlugDefinition.State: PlugState A persistent State of the Plug while the Socket plugin is running. We can write to this inside the PlugDefinition, and read/write to it in our Function and BindToClose/BindToOpen functions. We can declare default values for fields: { Fields = { { Name = &quot;Size&quot;; Type = &quot;Vector3&quot;; } } State = { FieldValues = { Size = Vector3.new(2, 2, 2); -- Will automatically appear on the Widget } } } We can also access IsRunning: local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- PlugDefinition that, when running, will print the time since the last frame { Function = function(plug, plugin) -- Toggle running state plug:ToggleIsRunning() -- Get Variables local timer = plug.State.FieldValues.Timer local isRunning = plug.State.IsRunning if isRunning then -- Add to our RunJanitor -- Automatically gets cleaned up when we toggle IsRunning to false via ToggleIsRunning -- Also gets cleaned up when BindToClose is called plug.RunJanitor:Add(Heartbeat:Connect(function(dt) Logger:PlugInfo(plug, (&quot;dt: %f&quot;)) end)) end end } Defaults to { FieldValues = {}; _Server = {}; _Client = {}; }   "},{"title":"RunJanitor​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#RunJanitor","content":"Read-Only &lt;/&gt; PlugDefinition.RunJanitor: Janitor A Janitor object, intended to be used to cleanup tasks after a plug stops running. Is automatically cleaned up when using plug:ToggleIsRunning(), and on BindToClose "},{"title":"Functions​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#functions","content":" "},{"title":"Function​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Function","content":"Required &lt;/&gt; PlugDefinition.Function( plug: PlugDefinition, plugin: Plugin ) → () The function that will be called when we Run the Plug. caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent  "},{"title":"BindToClose​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#BindToClose","content":"&lt;/&gt; PlugDefinition.BindToClose( plug: PlugDefinition, plugin: Plugin ) → () This is a function that is called when: The Socket Plugin is exited The Plug is removed while the Socket Plugin is running Use this to clean anything up instantiated by the Plug caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent Order of operations: 1) BindToClose is called 2) plug.State.IsRunning = false 3) plug.RunJanitor:Cleanup()  "},{"title":"BindToOpen​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#BindToOpen","content":"&lt;/&gt; PlugDefinition.BindToOpen( plug: PlugDefinition, plugin: Plugin ) → () This is a function that is called when the Socket plugin is started! This has some rare use cases. For the most part, Socket is really good at calling BindToClose when it is needed, but there are some Roblox limitations. Imagine we have a plug that makes significant changes in game.Workspace (e.g., changes the Color3 of part(s)). If Roblox Studio is suddenly closed, or crashes, it's possible the changes the plug made will be saved, but the &quot;stopping&quot; logic is never run. BindToOpen can be used to run checks to cleanup any mess left from the previous session. This is more a failsafe than a requirement, but can save headaches! For a good example use-case, see the Socket Core Plug .Locked caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent  "},{"title":"GetFieldValue​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GetFieldValue","content":"Read-Only &lt;/&gt; PlugDefinition:GetFieldValue(fieldName: string) → () Sugar for plug.State.FieldValues[fieldName]   "},{"title":"ToggleIsRunning​","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#ToggleIsRunning","content":"Read-Only &lt;/&gt; PlugDefinition:ToggleIsRunning() → () Sugar for plug.State.IsRunning = not plug.State.IsRunning if not plug.State.IsRunning then plug.RunJanitor:Cleanup() end  "}]