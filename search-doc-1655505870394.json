[{"title":"Logger","type":0,"sectionRef":"#","url":"api/Logger","content":"","keywords":""},{"title":"Functions‚Äã","type":1,"pageTitle":"Logger","url":"api/Logger#functions","content":" "},{"title":"PlugInfo‚Äã","type":1,"pageTitle":"Logger","url":"api/Logger#PlugInfo","content":"&lt;/&gt; Logger:PlugInfo( plug:¬†PlugDefinition, ...:¬†any ) ‚Üí¬†() For showing general information to the output  "},{"title":"PlugWarn‚Äã","type":1,"pageTitle":"Logger","url":"api/Logger#PlugWarn","content":"&lt;/&gt; Logger:PlugWarn( plug:¬†PlugDefinition, ...:¬†any ) ‚Üí¬†() For informing the user that an issue with a plug has occured "},{"title":"Examples","type":0,"sectionRef":"#","url":"docs/Examples","content":"Examples","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method 1 - Plugin‚Äã","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1---plugin","content":"Download the plugin here via Roblox "},{"title":"Method 2 - Git‚Äã","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---git","content":"If you don't trust Method 1 (I get it!), you can download the repo and compile the plugin yourself! (1) Clone the repository to your local machine‚Äã Open up the command terminalRoute to your desired directory via cd &lt;some directory&gt;Use git clone https://github.com/JoelBrd/Socket info No idea what git is? Check this video out, or strongly consider using Method 1 (2) Use Rojo to sync the project onto a Roblox Studio place‚Äã Please see the Rojo Docs on how to do this (3) Compile the plugin‚Äã Select game.ServerScriptService.SocketPlugin and game.ServerScriptService.SocketPlugin.PluginFrameworkRight Click -&gt; Save as Local PluginAfter selecting a name and saving, Socket will appear on your plugin toolbar! "},{"title":"PlugField","type":0,"sectionRef":"#","url":"api/PlugField","content":"","keywords":""},{"title":"Properties‚Äã","type":1,"pageTitle":"PlugField","url":"api/PlugField#properties","content":" "},{"title":"Type‚Äã","type":1,"pageTitle":"PlugField","url":"api/PlugField#Type","content":"Required &lt;/&gt; PlugField.Type: PlugFieldType   "},{"title":"Name‚Äã","type":1,"pageTitle":"PlugField","url":"api/PlugField#Name","content":"Required &lt;/&gt; PlugField.Name: string The name of this field. This is the same string used to reference this field within a plug.  "},{"title":"IsRequired‚Äã","type":1,"pageTitle":"PlugField","url":"api/PlugField#IsRequired","content":"&lt;/&gt; PlugField.IsRequired: boolean If true, the plug will not run + produce a PlugWarn in the output if a value has not been defined. "},{"title":"Functions‚Äã","type":1,"pageTitle":"PlugField","url":"api/PlugField#functions","content":" "},{"title":"Validator‚Äã","type":1,"pageTitle":"PlugField","url":"api/PlugField#Validator","content":"&lt;/&gt; PlugField.Validator(value:¬†any) ‚Üí¬†string We can define a Validator function to run our field value by when we run the plug. If there is an issue, we have Validator return a string detailing the issue. If everything is OK, return nil. A good use case is if the user can define a number, but we want to make sure it is non-negative. { Name = &quot;Height&quot;; PlugFieldType = &quot;number&quot;; Validator = function(someNumber) if someNumber &lt; 0 then return (&quot;Must be non-negative. Got: %d&quot;):format(someNumber) end end }  "},{"title":"PlugFieldType","type":0,"sectionRef":"#","url":"api/PlugFieldType","content":"","keywords":""},{"title":"Properties‚Äã","type":1,"pageTitle":"PlugFieldType","url":"api/PlugFieldType#properties","content":" "},{"title":"Name‚Äã","type":1,"pageTitle":"PlugFieldType","url":"api/PlugFieldType#Name","content":"&lt;/&gt; PlugFieldType.Name: string The string that should be referenced inside a PlugDefinition for a PlugField's PlugFieldType Socket comes with the following types: &quot;string&quot;|&quot;number&quot;|&quot;boolean&quot;|&quot;Color3&quot;|&quot;Vector3&quot;   "},{"title":"Icon‚Äã","type":1,"pageTitle":"PlugFieldType","url":"api/PlugFieldType#Icon","content":"&lt;/&gt; PlugFieldType.Icon: string A small string/emoji "},{"title":"Functions‚Äã","type":1,"pageTitle":"PlugFieldType","url":"api/PlugFieldType#functions","content":" "},{"title":"Validate‚Äã","type":1,"pageTitle":"PlugFieldType","url":"api/PlugFieldType#Validate","content":"&lt;/&gt; PlugFieldType.Validate(value:¬†string) ‚Üí¬†any¬†|¬†nil Takes an input value, and returns a type-safe version. Can return nil if there is nothing we can do with it.  "},{"title":"ToString‚Äã","type":1,"pageTitle":"PlugFieldType","url":"api/PlugFieldType#ToString","content":"&lt;/&gt; PlugFieldType.ToString(value:¬†any) ‚Üí¬†string Takes a type-safe value, and returns it as a string that can be put into the field TextBox on the UI. "},{"title":"TeamCreateUtil","type":0,"sectionRef":"#","url":"api/TeamCreateUtil","content":"","keywords":""},{"title":"Functions‚Äã","type":1,"pageTitle":"TeamCreateUtil","url":"api/TeamCreateUtil#functions","content":" "},{"title":"IntroduceInstance‚Äã","type":1,"pageTitle":"TeamCreateUtil","url":"api/TeamCreateUtil#IntroduceInstance","content":"&lt;/&gt; TeamCreateUtil:IntroduceInstance( instance:¬†Instance , dontSetWaypoint:¬†boolean¬†|¬†nil ) ‚Üí¬†() Brings an instance into the workspace in the context of Socket and the user calling this function. By default, sets a ChangeHistoryService waypoint.  "},{"title":"ClearInstance‚Äã","type":1,"pageTitle":"TeamCreateUtil","url":"api/TeamCreateUtil#ClearInstance","content":"&lt;/&gt; TeamCreateUtil:ClearInstance( instance:¬†Instance , doDestroy:¬†boolean ) ‚Üí¬†() Clears an instance from our context of Socket and the user calling this function. Should be an instance that was introduced via IntroduceInstance "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Content‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#content","content":"Installation guide "},{"title":"What is Socket?‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#what-is-socket","content":"Socket is a Roblox plugin that allows us to easily run code in Roblox Studio. Why do I need Socket when I have the Command Line?‚Äã You can obviously run code through the command line, but you're limited to this interface:  This interface is much nicer, don't you think?  Socket is a &quot;macro manager&quot;; we can pre-define code, and run it via the Run buttons on the Widget. There is functionality to run these &quot;macros&quot; via a keybind, we can define fields values for our macros to use and more. There are other tools out there that provide this &quot;macro manager&quot; functionality, so why use Socket? "},{"title":"Why Socket?‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#why-socket","content":"info &quot;Macros&quot; &lt;==&gt; &quot;Plugs&quot; Many would define Socket as a macro manager. Albeit true, it's design originated from wanting to create a plugin that could have the functionality of multiple plugins. In the real world, &quot;Plugs&quot; &quot;Plug in&quot; into &quot;Sockets&quot; - so Socket and it's Plugs were born! "},{"title":"Organisation‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#organisation","content":"Socket allows you to organise your Plugs into different groups, and easily view/access/run them. It mirrors the functionality of the Explorer tab with it's layout and ability to expand/collapse objects. You can also search through your Plugs to find what you're looking for in an instant. "},{"title":"Customisation‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#customisation","content":"While the Socket plugin adheres to your Studio theme, you can customise each Group and Plug as well as general settings! NamesIcons (Text and ImageId)Colors (TextColor3 and ImageColor3)Sort OrderFieldsKeybindsFontDefault StateUI Scaling   "},{"title":"Uses ModuleScripts‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#uses-modulescripts","content":"The way you define Plugs and add/remove/change them is via ModuleScripts! There is a game.ServerStorage.SocketPlugin directory where you can place multiple Plugs and any utility ModuleScripts. Easy management of your Plugs through both the Widget and Explorer tabReroute logic to Util files that multiple Plugs can accessUse the Roblox Studio script editor to write your codeEasily share Plugs between all team members on Team CreateSync your Plugs via Rojo (!!!) "},{"title":"Ergonomics‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#ergonomics","content":"Want to give some instructions on how to use your Plug incase your distributing it, or plan to use it 2 weeks from now? You can add a Description that can be easily viewed in 1 Click via the Widget. Whenever you make a change to a Plug, it will automatically update the Widget. If any changes break the integrity of the ModuleScript, you will be warned! It can be cumbersome to make changes whenever you want to alter the functionality of your Plug - Fields come to the rescue! You can define field values on the Widget that can then be read from instantly in your Plug Function "},{"title":"Automation‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#automation","content":"There is an obvious hint at automation with any kind of &quot;macro manager&quot;, but with Socket specifically: 1 Click to run any of your PlugsDefine a Keybind to run a Plug without using the Widget!Toggleable Plugs to turn routines on/off as you please Toggleable Plugs (See: PlugState)  -&gt;  "},{"title":"Server/Client Runners‚Äã","type":1,"pageTitle":"Introduction","url":"docs/intro#serverclient-runners","content":"When playtesting, you have the option to run your Plugs on the Server or Client. Super useful for checking Client -&gt; Server security.  "},{"title":"PlugDefinition","type":0,"sectionRef":"#","url":"api/PlugDefinition","content":"","keywords":""},{"title":"Types‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#types","content":" "},{"title":"PlugState‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#PlugState","content":"&lt;/&gt; interface PlugState { FieldValues:¬†table&lt;PlugField.Name,any&gt;-- Where we can read the values of our fields from IsRunning:¬†boolean¬†|¬†nil-- Use this variable to toggle the state of a Plug (updates the UI) Server:¬†PlugState-- Socket-only (used for communcicating Server/Client in Accurate Play Solo) Client:¬†PlugState-- Socket-only (used for communcicating Server/Client in Accurate Play Solo) } A table to store a plug's &quot;State&quot;. Socket writes some stuff here, but feel free to use this for whatever you need. If you overwrite any keys that Socket uses (fields defined here), expect mayhem and tears! "},{"title":"Properties‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#properties","content":" "},{"title":"Name‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Name","content":"Required &lt;/&gt; PlugDefinition.Name: string Declares the name that will appear on the Widget for the Plug. caution Longer names will be less readable on the Widget, depending on a user's resolution  "},{"title":"NameColor‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#NameColor","content":"&lt;/&gt; PlugDefinition.NameColor: Color3  Give your Plug a pretty color on the Widget! Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Icon‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Icon","content":"&lt;/&gt; PlugDefinition.Icon: string Defines an icon to put alongside the Name of the Plug. This can either be Text (e.g., Emoji) or an ImageId. ImageIds are recognised by the string containing rbxassetid { Icon = &quot;üìÇ&quot; -- Good Icon = &quot;My Icon&quot; -- Probably too long, but good Icon = &quot;&quot; -- Bit boring, but good Icon = &quot;rbxassetid://9553550332&quot; -- Good ImageId Icon = &quot;https://www.roblox.com/library/9553550338/&quot; -- Bad ImageId (Website) Icon = &quot;http://www.roblox.com/asset/?id=9553550332&quot; -- Bad ImageId (Decal) }   "},{"title":"IconColor‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#IconColor","content":"&lt;/&gt; PlugDefinition.IconColor: Color3  Give your Plug icon a pretty color on the Widget! Applies to TextColor3 or ImageColor3, depending on Icon input Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Group‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Group","content":"&lt;/&gt; PlugDefinition.Group: string The group that the Plug belongs to. Any plugs with matching Group will be group together on the Widget  "},{"title":"GroupColor‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GroupColor","content":"&lt;/&gt; PlugDefinition.GroupColor: Color3  Give a Group a pretty color on the Widget! If you have multiple Plugs under the same Group, GroupColor need only be defined on a singular PlugDefinition Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"GroupIcon‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GroupIcon","content":"&lt;/&gt; PlugDefinition.GroupIcon: string Defines an icon to put alongside the name of the Group the Plug is under. If you have multiple Plugs under the same Group, GroupIcon need only be defined on a singular PlugDefinition This can either be Text (e.g., Emoji) or an ImageId. ImageIds are recognised by the string containing rbxassetid { Icon = &quot;üìÇ&quot; -- Good Icon = &quot;My Icon&quot; -- Probably too long, but good Icon = &quot;&quot; -- Bit boring, but good Icon = &quot;rbxassetid://9553550332&quot; -- Good ImageId Icon = &quot;https://www.roblox.com/library/9553550338/&quot; -- Bad ImageId (Website) Icon = &quot;http://www.roblox.com/asset/?id=9553550332&quot; -- Bad ImageId (Decal) }   "},{"title":"GroupIconColor‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GroupIconColor","content":"&lt;/&gt; PlugDefinition.GroupIconColor: Color3  Give your Plug icon a pretty color on the Widget! Applies to TextColor3 or ImageColor3, depending on Icon input. If you have multiple Plugs under the same Group, GroupIconColor need only be defined on a singular PlugDefinition Defaults to Color.fromRGB(255, 255, 255)  "},{"title":"Description‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Description","content":"&lt;/&gt; PlugDefinition.Description: string Any and all information pertaining to this specific Plug. This can be as long as you like as it appears in the output. { Description = &quot;Plug Description Line 1\\nPlug Description Line 2&quot; } Output: ================ Plug Name (Plug Group) | DESCRIPTION ================ Plug Description Line 1 Plug Description Line 2 ================ Plug Name (Plug Group) | DESCRIPTION ================   "},{"title":"EnableAutomaticUndo‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#EnableAutomaticUndo","content":"&lt;/&gt; PlugDefinition.EnableAutomaticUndo: boolean If true, will automatically setup ChangeHistoryService waypoints before and after running the Plug's Function. AKA, any changes to studio that your Plug makes, you can undo with Ctrl+Z or equivalent. You can obviously set this to false (or don't declare the field) if you want to write your own implementation. tip When you run &quot;Undo&quot; in Studio, it will undo the last change under the DataModel (game). If your Plug just prints to the output (and doesn't make any changes to the DataModel) it will undo your last change unrelated to your Plug  "},{"title":"IgnoreGameProcessedKeybinds‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#IgnoreGameProcessedKeybinds","content":"&lt;/&gt; PlugDefinition.IgnoreGameProcessedKeybinds: boolean Socket uses UserInputService#InputBegan for detecting keybinds. game:GetService(&quot;UserInputService&quot;).InputBegan:Connect(function(inputObject, gameProcessedEvent) if gameProcessedEvent and not IgnoreGameProcessedKeybinds then return end ... end)   "},{"title":"AutoRun‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#AutoRun","content":"&lt;/&gt; PlugDefinition.AutoRun: boolean If true, plug.Function will be called when Socket starts. Useful if there is a plug you always want running  "},{"title":"Keybind‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Keybind","content":"&lt;/&gt; PlugDefinition.Keybind: {Enum.KeyCode} An array of Enum.KeyCode that can trigger the Plug to run. { Keybind = { Enum.KeyCode.LeftControl, Enum.KeyCode.J } } tip Will not work if any of the inputs have gameProcessedEvent set to true. See: UserInputService  "},{"title":"Fields‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Fields","content":"&lt;/&gt; PlugDefinition.Fields: {PlugField} An array of PlugField, which define the different fields the Plug has { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; }, { Name = &quot;Title&quot;; Type = &quot;string&quot;; } } }   "},{"title":"FieldChanged‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#FieldChanged","content":"&lt;/&gt; PlugDefinition.FieldChanged: BindableEvent  A BindableEvent to listen to field values being changed on the UI! plug.FieldChanged.Event:Connect(function(fieldName, fieldValue) -- plug:GetFieldValue(fieldName) === fieldValue end) Most cases it will suffice to just read plug:GetFieldValue(fieldName) as and when you need a field value. But sometimes you may need to re-run some routines after a field value change.  "},{"title":"State‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#State","content":"&lt;/&gt; PlugDefinition.State: PlugState A persistent State of the Plug while the Socket plugin is running. We can write to this inside the PlugDefinition, and read/write to it in our Function and BindToState functions. We can declare default values for fields: { Fields = { { Name = &quot;Size&quot;; Type = &quot;Vector3&quot;; } } State = { FieldValues = { Size = Vector3.new(2, 2, 2); } } } We can also access IsRunning: local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- PlugDefinition that, when running, will print the time since the last frame { Fields = { { Name = &quot;Timer&quot;; Type = &quot;number&quot;; IsRequired = true; } } State = { IsRunning = false } Function = function(plug, plugin) -- Toggle running state plug.State.IsRunning = not plug.State.IsRunning -- Get Variables local timer = plug.State.FieldValues.Timer local isRunning = plug.State.IsRunning if isRunning then plug.State.HeartbeatConnection = Heartbeat:Connect(function(dt) Logger:PlugInfo(plug, (&quot;dt: %f&quot;)) end) elseif plug.State.HeartbeatConnection then plug.State.HeartbeatConnection:Disconnect() plug.State.HeartbeatConnection = nil end end BindToClose = function(plug, plugin) if plug.State.HeartbeatConnection then plug.State.HeartbeatConnection:Disconnect() plug.State.HeartbeatConnection = nil end end }   "},{"title":"RunJanitor‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#RunJanitor","content":"&lt;/&gt; PlugDefinition.RunJanitor: Janitor A Janitor object, intended to be used to cleanup tasks after a plug stops running. Is automatically cleaned up when using plug:ToggleIsRunning() "},{"title":"Functions‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#functions","content":" "},{"title":"Function‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#Function","content":"Required &lt;/&gt; PlugDefinition.Function( plug:¬†PlugDefinition, plugin:¬†Plugin ) ‚Üí¬†() The function that will be called when we Run the Plug. caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent  "},{"title":"BindToClose‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#BindToClose","content":"&lt;/&gt; PlugDefinition.BindToClose( plug:¬†PlugDefinition, plugin:¬†Plugin ) ‚Üí¬†() This is a function that is called when: The Socket Plugin is exited The Plug is removed while the Socket Plugin is running Use this to clean anything up instantiated by the Plug tip Along with BindToClose being called, we also set IsRunning=false caution This function is not allowed to yield; wrap any yielding routines in a task.spawn or equivalent  "},{"title":"BindToOpen‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#BindToOpen","content":"&lt;/&gt; PlugDefinition.BindToOpen( plug:¬†PlugDefinition, plugin:¬†Plugin ) ‚Üí¬†() This is a function that is called when the Socket plugin is started! This has some rare use cases. For the most part, Socket is really good at calling BindToClose when it is needed, but there are some Roblox limitations. Imagine we have a plug that makes significant changes in game.Workspace (e.g., changes the Color3 of part(s)). If Roblox Studio is suddenly closed, or crashes, it's possible the changes the plug made will be saved, but the stopping logic is never ran. BindToOpen can be used to run checks to cleanup any mess left from the previous session. This is more a failsafe than a requirement, but will save headaches! For a good example use-case, see the Socket Core Plug .Locked  "},{"title":"GetFieldValue‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#GetFieldValue","content":"&lt;/&gt; PlugDefinition:GetFieldValue(fieldName:¬†string) ‚Üí¬†() Sugar for plug.State.FieldValues[fieldName]   "},{"title":"ToggleIsRunning‚Äã","type":1,"pageTitle":"PlugDefinition","url":"api/PlugDefinition#ToggleIsRunning","content":"&lt;/&gt; PlugDefinition:ToggleIsRunning() ‚Üí¬†() Sugar for plug.State.IsRunning = not plug.State.IsRunning if not plug.State.IsRunning then plug.RunJanitor:Cleanup() end  "},{"title":"Adding Your First Plug","type":0,"sectionRef":"#","url":"docs/YourFirstPlug","content":"","keywords":""},{"title":"Creating a new Plug‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#creating-a-new-plug","content":"Let's make use of one of our Core Plugs, Create Plug to create your first plug This creates a ModuleScript in the SocketPlugin.Plugs directory info You can create folders in this directory to help organise your Plugs; but the Group of a Plug is defined within the ModuleScript itself You'll get a ModuleScript with a Source similar to: --- ---Plug Template --- -------------------------------------------------- -- Types -- ... -------------------------------------------------- -- Dependencies local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Constants -- ... -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;No Group&quot;, ---@type string GroupColor = nil, ---@type Color3 GroupIcon = nil, ---@type string GroupIconColor = nil, ---@type Color3 Name = &quot;No Name&quot;, NameColor = nil, ---@type Color3 Icon = &quot;üîå&quot;, IconColor = nil, ---@type Color3 Description = &quot;No Name Description&quot;, ---@type string State = {}, ---@type PlugState EnableAutomaticUndo = false, ---@type boolean Keybind = {}, ---@type Enum.KeyCode[] Fields = {}, ---@type PlugField[] Function = nil, ---@type fun(plug:PlugDefinition, plugin:Plugin) BindToClose = nil, ---@type fun(plug:PlugDefinition, plugin:Plugin) } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) Logger:PlugInfo(plug, &quot;Hello!&quot;) end return plugDefinition Copy You'll notice we're returning a table with a bunch of key/value pairs. For a full breakdown of these, and what they each do, see PlugDefinition. There are 2 required key/value pairs: NameFunction Everything else is optional, or will be populated with a default value. tip Try editing some of these fields, and see how the Widget updates! Keep an eye on the output window incase there are any issues with your PlugDefinition. "},{"title":"Creating our code‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#creating-our-code","content":"We now have a fresh Plug, and have played around with how it appears on the Widget. Lets take a look at the tools we have when defining our Function "},{"title":"Parameters‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#parameters","content":"Function gets passed 2 parameters; plug: PlugDefinition, plugin: [Plugin]. plug is our PlugDefinition. It is important we reference plug, and not plugDefinition. Changes are made outside the scope of the ModuleScript (e.g., if we change a Field value on the Widget, this is written to plug and not plugDefinition)plugin is the actual [Plugin] object that Socket is under; this is passed for special use cases, as the [Plugin] object has unique API "},{"title":"Logging‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#logging","content":"You'll notice in the template Plug that gets created, a required Logger file. This gives us access to: Logger:PlugInfo(plug, &quot;Hello!&quot;) -- &lt;==&gt; print((&quot;[%s %s] %s&quot;):format(plug.Icon or &quot;&quot;, plug.Name, &quot;Hello!&quot;)) Logger:PlugWarn(plug, &quot;Uh Oh!&quot;) -- &lt;==&gt; warn((&quot;[%s %s] %s&quot;):format(plug.Icon or &quot;&quot;, plug.Name, &quot;Hello!&quot;)) Copy This is just a nice way to print to the output, and show the Plug scope it came from. This is the same API used for when Socket detects an issue with a Plug and wants to inform the user (e.g., a required Field is missing its value) "},{"title":"Using plug Parameter‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#using-plug-parameter","content":"You can reference any members of plug (see PlugDefinition) - most notably plug.State (see PlugState) plug.State.IsRunning‚Äã We can use this value to toggle the state of our Plug, so we can have a routine that gets toggled on/off. You could declare your own variable in plug.State to do this, but using IsRunning will give us some nice feedback on the Widget UI. plug.State.FieldValues‚Äã This is where we access the values of our fields, and make use of them. If we have declared a field such as: { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; } } } Copy We can access the value vialocal amount = plug.State.FieldValues.AmountNote that amount may not exist, so we can either: Run this check in our FunctionDo  { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; IsRequired = true; } } } Copy If IsRequired=true, we will get a Logger:PlugWarn in our output if we run the plug and we have not declared a value for the Field. We can assume it exists in our Function now! A nice trick we can do is if we want to declare a default value for a Field, we can mirror the following structure in our PlugDefinition { Fields = { { Name = &quot;Amount&quot;; Type = &quot;number&quot;; } } State = { FieldValues = { Amount = 1; } } } Copy "},{"title":"BindToClose‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#bindtoclose","content":"Imagine we have a Plug that is running routines (IsRunning=true), but we then delete the ModuleScript for that Plug, or we close the [Plugin]? We could still have code running that would've normally been stopped by toggling the Plug. This is where BindToClose comes in. Example:  local Heartbeat = game:GetService(&quot;RunService&quot;).Heartbeat -- PlugDefinition that, when running, will print the time since the last frame local plugDefinition = { -- ... Fields = { { Name = &quot;Timer&quot;; Type = &quot;number&quot;; IsRequired = true; } } State = { IsRunning = false } Function = function(plug, plugin) -- Toggle running state plug.State.IsRunning = not plug.State.IsRunning -- Get Variables local timer = plug.State.FieldValues.Timer local isRunning = plug.State.IsRunning if isRunning then plug.State.HeartbeatConnection = Heartbeat:Connect(function(dt) Logger:PlugInfo(plug, (&quot;dt: %f&quot;)) end) elseif plug.State.HeartbeatConnection then plug.State.HeartbeatConnection:Disconnect() plug.State.HeartbeatConnection = nil end end BindToClose = function(plug, plugin) if plug.State.HeartbeatConnection then plug.State.HeartbeatConnection:Disconnect() plug.State.HeartbeatConnection = nil end end -- ... } Copy In the above situation, toggling IsRunning from outside the scope of Function will still cause routines to keep running! BindToClose saves the day by ensuring HeartbeatConnection is disconnected. tip Naturally when BindToClose is called by Socket, we also toggle IsRunning=false - so if you hade a routine like: while plug.State.IsRunning do -- ... end Copy The loop would stop and does not require a BindToClose function "},{"title":"Midas Touch Plug‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#midas-touch-plug","content":"Lets go through an example here by creating a Plug that makes parts look golden. "},{"title":"Create the Plug‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#create-the-plug","content":"We'll start off by placing a ModuleScript at game.ServerStorage.SocketPlugin.Plugs.MidasTouch: --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, Name = &quot;Midas Touch&quot;, Description = &quot;Makes parts gold&quot;, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) Logger:PlugInfo(plug, &quot;I command you to make parts golden!&quot;) end return plugDefinition Copy Result:  "},{"title":"Make it pretty‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#make-it-pretty","content":"This is looking a touch bland on our Widget, lets juice it up a bit. local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = Color3.fromRGB(255, 180, 0), GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Makes parts gold&quot;, } Copy Better!  "},{"title":"v1‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#v1","content":"The Plug currently doesn't do anything, other than print a silly message to the output window. Lets make it so when we run the Midas Touch Plug, it will make any parts that we have selected turn to gold: --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) -- Get our selected instances, and filter out any non-parts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) then if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = COLOR_GOLD part.Material = Enum.Material.Foil end Logger:PlugInfo(plug, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end return plugDefinition Copy Cool!  "},{"title":"v2‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#v2","content":"Automatic Undo‚Äã v1 was all well and good, but what if I accidentally gold-ify a part that I didn't want to? We need to setup ChangeHistoryService waypoints to implement this, or we can simply do: EnableAutomaticUndo = true Copy More colors‚Äã I'm also not super happy with it always being the same color; lets add 2 color fields that we will uniformly interpolate between. { Fields = { { Name = &quot;Color1&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;Color2&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, } } Copy  Real time‚Äã Finally, I don't want to have to click Run, or use a Keybind, to make a part gold. I want to Make the Plug toggleableWhenever the Plug is running, any parts I select will turn to gold in real time. Lets write some code to make this happen.. --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, EnableAutomaticUndo = true, Fields = { { Name = &quot;ColorA&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;ColorB&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, }, State = { IsRunning = false, }, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) -- Toggle running plug.State.IsRunning = not plug.State.IsRunning -- Get Variables local isRunning = plug.State.IsRunning local colorA = plug.State.FieldValues.ColorA local colorB = plug.State.FieldValues.ColorB if isRunning then plug.State.SelectionChangedConnection = Selection.SelectionChanged:Connect(function() -- Get our selected instances, and filter out any non-parts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) do if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = colorA:Lerp(colorB, math.random()) part.Material = Enum.Material.Foil end if #parts &gt; 0 then Logger:PlugInfo(plug, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end end) else plug.State.SelectionChangedConnection:Disconnect() plug.State.SelectionChangedConnection = nil end end return plugDefinition Copy Fantastic &lt;3  "},{"title":"v3‚Äã","type":1,"pageTitle":"Adding Your First Plug","url":"docs/YourFirstPlug#v3","content":"With v2, if we close Socket while running the Midas Touch Plug, we will be encrusting parts forever as we never toggle the Plug to stop it running. The Solution: ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.BindToClose = function(plug, plugin) if plug.State.SelectionChangedConnection then plug.State.SelectionChangedConnection:Disconnect() plug.State.SelectionChangedConnection = nil end end Copy Our Final Plug‚Äã --- ---Midas Touch --- -------------------------------------------------- -- Dependencies local Selection = game:GetService(&quot;Selection&quot;) local ServerStorage = game:GetService(&quot;ServerStorage&quot;) ---@type ServerStorage local Utils = ServerStorage.SocketPlugin:FindFirstChild(&quot;Utils&quot;) local Logger = require(Utils.Logger) ---@type Logger -------------------------------------------------- -- Constants local COLOR_GOLD = Color3.fromRGB(255, 180, 0) -------------------------------------------------- -- Members ---@type PlugDefinition local plugDefinition = { Group = &quot;Golden&quot;, GroupColor = COLOR_GOLD, GroupIcon = &quot;üëë&quot;, Name = &quot;Midas Touch&quot;, Icon = &quot;ü§è&quot;; Description = &quot;Converts any parts we have selected turn to gold&quot;, EnableAutomaticUndo = true, Fields = { { Name = &quot;ColorA&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, { Name = &quot;ColorB&quot;, Type = &quot;Color3&quot;, IsRequired = true, }, }, State = { IsRunning = false, }, } ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.Function = function(plug, plugin) -- Toggle running plug.State.IsRunning = not plug.State.IsRunning -- Get Variables local isRunning = plug.State.IsRunning local colorA = plug.State.FieldValues.ColorA local colorB = plug.State.FieldValues.ColorB if isRunning then plug.State.SelectionChangedConnection = Selection.SelectionChanged:Connect(function() -- Get our selected instances, and filter out any non-parts local selectedInstances = Selection:Get() local parts = {} for _,instance in pairs(selectedInstances) do if instance:IsA(&quot;BasePart&quot;) then table.insert(parts, instance) end end -- Apply a gold finish to each part for _,part in pairs(parts) do part.Color = colorA:Lerp(colorB, math.random()) part.Material = Enum.Material.Foil end if #parts &gt; 0 then Logger:PlugInfo(plug, (&quot;I encrusted %d parts with gold!&quot;):format(#parts)) end end) else plug.State.SelectionChangedConnection:Disconnect() plug.State.SelectionChangedConnection = nil end end ---@param plug PlugDefinition ---@param plugin Plugin plugDefinition.BindToClose = function(plug, plugin) if plug.State.SelectionChangedConnection then plug.State.SelectionChangedConnection:Disconnect() plug.State.SelectionChangedConnection = nil end end return plugDefinition Copy "}]